# LeetCode
leetcode 目录
* [一、有关数组的题目](#一有关数组的题目)
  * [1、二分查找法的应用](#1-二分查找法的应用)
    * [(1) 704、二分查找](#1704-二分查找)
    * [(2) 35、搜索插入位置](#235-搜索插入位置)
    * [(3) 34、在排序数组中查找元素的第一个和最后一个位置](#334在排序数组中查找元素的第一个和最后一个位置)
    * [(4) 69、x的平方根](#469x的平方根)
    * [(5) 367、有效的完全平方数](#5367有效的完全平方数)
  * [2、移除元素](#2-移除元素)
    * [(6) 27、移除元素](#127移除元素)
    * [(7) 26、删除有序数组中的重复项](#226删除有序数组中的重复项)
    * [(8) 283、移动零](#3283移动零)
    * [(9) 844、比较含退格的字符串](#4844比较含退格的字符串)
    * [(10) 977、有序数组的平方](#5977有序数组的平方)
  * [3、滑动窗口](#3滑动窗口)
    * [(11) 209、长度最小的数组](#1209长度最小的数组)
    * [(12) 904、水果成篮](#2904水果成篮)
    * [(13) 76、最小覆盖子串](#376最小覆盖子串)
  * [4、螺旋矩阵](#4螺旋矩阵)
    * [(14) 59、螺旋矩阵II](#159螺旋矩阵ii)
    * [(15) 54、螺旋矩阵](#254螺旋矩阵)
    * [(16) 29、顺时针打印矩阵](#329顺时针打印矩阵)
* [二、链表](#二链表)
  * [(1) 203、移除链表](#1203移除俩表)
  * [(2) 707、设计链表](#2707设计链表)
  * [(3) 206、反转链表](#3-206反转链表)
  * [(4) 24、两两交换链表中的节点](#4-24两两交换链表中的节点)
  * [(5) 19、删除链表中倒数第N个节点](#519删除链表中倒数第n个节点)
  * [(6) 142、环形链表](#6142环形链表)
* [三、哈希表](#三哈希表)
  * [1、异位词](#1异位词)
    * [(1) 242、有效的字母异位词](#1242有效的字母异位词)
    * [(2) 383、赎金信](#2383赎金信)
    * [(3) 49、字母异位词分组](#349字母异位词分组)
    * [(4) 438、找到字符串中所有字母异位词](#4438找到字符串中所有字母异位词)
  * [2、数组交集](#2数组交集)
    * [(5) 349、两个数组的交集](#1349两个数组的交集)
  * [3、快乐数](#3快乐数)
    * [(6) 202、快乐数](#1202快乐数)
  * [4、数的和](#4数的和)
    * [(7) 1、两数之和](#11两数之和)
    * [(8) 454、四数相加II](#2454四数相加ii)
    * [(9) 15、三数之和](#315三数之和)
    * [(10) 18、四数之和](#418四数之和)
* [四、字符串的题目](#四字符串的题目)
  * [(1) 344、反转字符串](#1344反转字符串)
  * [(2) 541、反转字符串II](#2541反转字符串ii)
  * [(3) 05、替换空格](#305替换空格)
  * [(4) 151、翻转字符串里的单词](#4151翻转字符串里的单词)
  * [(5) 58、左旋字符串](#558左旋字符串)
  * [(6) 28、实现strStr()](#628实现strstr)
  * [(7) 459、重复的字符串](#6459重复的字符串)
* [五、双指针法的题目](#五双指针法的题目)
  * [(1) 27、移除元素](#1-27移除元素)
  * [(2) 344、反转字符串](#2-344反转字符串)
  * [(3) 剑指05、替换空格](#3-剑指05替换空格)
  * [(4) 151、翻转字符串里的单词](#4-151翻转字符串里的单词)
  * [(5) 206、翻转链表](#5-206翻转链表)
  * [(6) 19、删除链表的倒数第N个节点](#6-19删除链表的倒数第n个节点)
  * [(7) 0207、链表相交](#70207链表相交)
  * [(8) 142、环形链表II](#8-142环形链表ii)
  * [(9) 15、三数之和](#9-15三数之和)
  * [(10) 18、四数之和](#10-18四数之和)
* [六、栈与队列](#六栈与队列)
  * [(1) 232、用栈实现队列](#1232用栈实现队列)
  * [(2) 225、用队列实现栈](#2-225用队列实现栈)
  * [(3) 20、有效的括号](#3-20有效的括号)
  * [(4) 1047、删除字符串中的所有相邻重复项](#4-1047删除字符串中的所有相邻重复项)
  * [(5) 150、逆波兰表达式求值](#5-150逆波兰表达式求值)
  * [(6) 239、滑动窗口最大值](#6-239滑动窗口最大值)
  * [(7) 347、前K个高频元素](#7-347前k个高频元素)
* [七、二叉树的题目](#七二叉树的题目)
  * [1、二叉树的遍历方式](#1-二叉树的遍历方式)
    * [(1) 144、二叉树的前序遍历](#1144二叉树的前序遍历)
    * [(2) 145、二叉树的后序遍历](#2145二叉树的后序遍历)
    * [(3) 94、二叉树的中序遍历](#394二叉树的中序遍历)
    * [(4) 102、二叉树的层序遍历](#4102二叉树的层序遍历)
    * [(5) 107、二叉树的层序遍历II](#5107二叉树的层序遍历ii)
    * [(6) 199、二叉树的右视图](#6-199二叉树的右视图)
    * [(7) 637、二叉树的层平均值](#7-637二叉树的层平均值)
    * [(8) 429、N叉树的层序遍历](#8-429n叉树的层序遍历)
    * [(9) 515、在每个树行中找最大值](#9-515在每个树行中找最大值)
    * [(10) 116、填充每个节点的下一个右侧节点指针](#10-116填充每个节点的下一个右侧节点指针)
    * [(11) 117、填充每个节点的下一个右侧节点指针II](#11117填充每个节点的下一个右侧节点指针ii)
  * [2、 求二叉树的属性](#2-求二叉树的属性)
    * [(12) 226、翻转二叉树](#12-226翻转二叉树)
    * [(13) 101、对称二叉树](#13-101对称二叉树)
    * [(14) 104、二叉树的最大深度](#14-104二叉树的最大深度)
    * [(15）559、N叉树的最大深度](#15559n叉树的最大深度)
    * [(16) 111、二叉树的最小深度](#16-111二叉树的最小深度)
    * [(17) 222、完全二叉树的节点个数](#17-222完全二叉树的节点个数)
    * [(18) 110、平衡二叉树](#18-110平衡二叉树)
    * [(19) 257、二叉树的所有路径](#19-257二叉树的所有路径)
    * [(20) 404、左叶子之和](#20-404左叶子之和)
    * [(21) 513、找树左下角的值](#21-513找树左下角的值)
    * [(22) 112、路径总和](#22-112路径总和)
    * [(23) 113、路径总和II](#23-113路径总和ii)
  * [3、 二叉树的修改与构造](#3-二叉树的修改与构造)
    * [(24) 106、从中序与后序遍历序列构造二叉树](#24-106从中序与后序遍历序列构造二叉树)
    * [(25) 105、从前序与中序遍历序列构造二叉树](#25-105从前序与中序遍历序列构造二叉树)
    * [(26) 654、最大二叉树](#26-654最大二叉树)
    * [(27) 617、合并二叉树](#27-617合并二叉树)
  * [4、 求二叉搜索树的属性](#4-求二叉搜索树的属性)
    * [(28) 700、二叉搜索树中的搜索](#28-700二叉搜索树中的搜索)
    * [(29) 98、验证二叉搜索树](#29-98验证二叉搜索树)
    * [(30) 530、二叉搜索树的最小绝对差](#30-530二叉搜索树的最小绝对差)
    * [(31) 501、二叉树搜索树中的众数](#31-501二叉树搜索树中的众数)
  * [5、 二叉树的公共祖先问题](#5-二叉树的公共祖先问题)
    * [(32) 236、二叉树的最近公共祖先](#32-236二叉树的最近公共祖先)
    * [(33) 235、二叉搜索树的最近公共祖先](#33-235二叉搜索树的最近公共祖先)
  * [6、 二叉搜索树的修改与构造](#6-二叉搜索树的修改与构造)
    * [(34) 701、二叉搜索树中的插入操作](#34-701二叉搜索树中的插入操作)
    * [(35) 450、删除二叉搜索树中的节点](#35-450删除二叉搜索树中的节点)
    * [(36) 669、修剪二叉搜索树](#36-669修剪二叉搜索树)
    * [(37) 108、将有序数组转换为二叉搜索树](#37-108将有序数组转换为二叉搜索树)
    * [(38) 538、把二叉搜索树转换为累加树](#38-538把二叉搜索树转换为累加树)
* [八、回溯算法 <a href="\./README\.md">↑</a>](#八回溯算法-)
  * [1、组合 <a href="\./README\.md">↑</a>](#1组合-)
    * [(1) 77、组合](#1-77组合)
    * [(2) 216、组合总和III](#2-216组合总和iii)
    * [(3) 17、电话号码的字母组合](#3-17电话号码的字母组合)
    * [(4) 39、组合总和](#4-39组合总和)
    * [(5) 40、组合总和II](#5-40组合总和ii)
  * [2、分割 <a href="\./README\.md">↑</a>](#2分割-)
    * [(6) 131、分割回文串](#6-131分割回文串)
    * [(7) 93、复原IP地址](#7-93复原ip地址)
  * [3、子集 <a href="\./README\.md">↑</a>](#3子集-)
    * [(8) 78、子集](#8-78子集)
    * [(9) 90、子集II](#9-90子集ii)
  * [4、排列 <a href="\./README\.md">↑</a>](#4排列-)
    * [(10) 491、递增子序列](#10-491递增子序列)
    * [(11) 46、全排列](#11-46全排列)
    * [(12) 47、全排列II](#12-47全排列ii)
    * [(13) 332、重新安排行程](#13-332重新安排行程)
  * [5、棋盘问题 <a href="\./README\.md">↑</a>](#5棋盘问题-)
    * [(14) 51、N皇后问题](#14-51n皇后问题)
    * [(15) 37、解数独](#15-37解数独)
* [九、贪心算法 <a href="\./README\.md">↑</a>](#九贪心算法-)
  * [1、简单题目 <a href="\./README\.md">↑</a>](#1简单题目-)
    * [(1) 455、分发饼干](#1-455分发饼干)
    * [(2) 1005、K次取反后最大化的数组和](#2-1005k次取反后最大化的数组和)
    * [(3) 860、柠檬水找零](#3-860柠檬水找零)
  * [2、序列问题 <a href="\./README\.md">↑</a>](#2序列问题-)
    * [(4) 376、摆动序列](#4-376摆动序列)
    * [(5) 738、单调递增的数字](#5-738单调递增的数字)
  * [3、贪心算法解决股票问题 <a href="\./README\.md">↑</a>](#3贪心算法解决股票问题-)
    * [(6) 122、买卖股票的最佳时机II](#6-122买卖股票的最佳时机ii)
    * [(7) 714、买卖股票的最佳时机含手续费](#7-714买卖股票的最佳时机含手续费)
  * [4、两个维度的权衡问题 <a href="\./README\.md">↑</a>](#4两个维度的权衡问题-)
    * [(8) 135、分发糖果](#8-135分发糖果)
    * [(9) 406、根据身高重建序列](#9-406根据身高重建序列)
  * [5、区间问题 <a href="\./README\.md">↑</a>](#5区间问题-)
    * [(10) 55、跳跃游戏](#10-55跳跃游戏)
    * [(11) 45、跳跃游戏II](#11-45跳跃游戏ii)
    * [(12) 452、用最少数量的箭引爆气球](#12-452用最少数量的箭引爆气球)
    * [(13) 435、无重叠区间](#13-435无重叠区间)
    * [(14) 763、划分字母区间](#14-763划分字母区间)
    * [(15) 56、合并区间](#15-56合并区间)
  * [6、其他 <a href="\./README\.md">↑</a>](#6其他-)
    * [(16) 134、加油站](#16-134加油站)
    * [(17) 53、最大子序和](#17-53最大子序和)
    * [(18) 968、监控二叉树](#18-968监控二叉树)
* [十、动态规划问题 <a href="\./README\.md">↑</a>](#十动态规划问题-)
  * [1、基础题目 <a href="\./README\.md">↑</a>](#1基础题目-)
    * [(1) 509、斐波那契数](#1-509斐波那契数)
    * [(2) 70、爬楼梯](#2-70爬楼梯)
    * [(3) 746、使用最小花费爬楼梯](#3-746使用最小花费爬楼梯)
    * [(4) 62、不同路径](#4-62不同路径)
    * [(5) 63、不同路径II](#5-63不同路径ii)
    * [(6) 343、整数拆分](#6-343整数拆分)
    * [(7) 96、不同的二叉搜索树](#7-96不同的二叉搜索树)
  * [2、背包问题 <a href="\./README\.md">↑</a>](#2背包问题-)
  * [2\.1 01背包 <a href="\./README\.md">↑</a>](#21-01背包-)
    * [(8) 01背包问题](#8-01背包问题)
      * [问题描述:](#问题描述)
      * [C\+\+实现](#c实现)
    * [(9) 416、分割等和子集](#9-416分割等和子集)
    * [(10) 1049、最后一块石头的重量II](#10-1049最后一块石头的重量ii)
    * [(11) 494、目标和](#11-494目标和)
    * [(12) 474、一和零](#12-474一和零)
  * [2\.2 完全背包 <a href="\./README\.md">↑</a>](#22-完全背包-)
    * [(13) 完全背包问题](#13-完全背包问题)
      * [问题描述:](#问题描述-1)
      * [C\+\+代码实现](#c代码实现)
    * [(14) 518、零钱兑换II](#14-518零钱兑换ii)
    * [(15) 377、组合总和IV](#15-377组合总和iv)
    * [(16) 70、爬楼梯](#16-70爬楼梯)
    * [(17) 322、零钱兑换](#17-322零钱兑换)
    * [(18) 276、完全平方数](#18-276完全平方数)
    * [(19) 139、单词拆分](#19-139单词拆分)
  * [2\.3 多重背包 <a href="\./README\.md">↑</a>](#23-多重背包-)
    * [(20) 多重背包问题:](#20-多重背包问题)
      * [问题描述：](#问题描述-2)
      * [C\+\+实现](#c实现-1)
  * [3、打家劫舍 <a href="\./README\.md">↑</a>](#3打家劫舍-)
    * [(21) 198、打家劫舍](#21-198打家劫舍)
    * [(22) 213、打家劫舍II](#22-213打家劫舍ii)
    * [(23) 337、打家劫舍III](#23-337打家劫舍iii)
  * [4、股票问题 <a href="\./README\.md">↑</a>](#4股票问题-)
    * [(24) 121、买卖股票的最佳时机](#24-121买卖股票的最佳时机)
    * [(25) 122、买卖股票的最佳时机II](#25-122买卖股票的最佳时机ii)
    * [(26) 123、买卖股票的最佳时机III](#26-123买卖股票的最佳时机iii)
    * [(27) 188、买卖股票的最佳时机IV](#27-188买卖股票的最佳时机iv)
    * [(28) 309、最佳买卖股票时机含冷冻期](#28-309最佳买卖股票时机含冷冻期)
    * [(29) 714、买卖股票的最佳时机含手续费](#29-714买卖股票的最佳时机含手续费)
  * [5、子序列问题 <a href="\./README\.md">↑</a>](#5子序列问题-)
  * [5\.1 子序列不连续 <a href="\./README\.md">↑</a>](#51-子序列不连续-)
    * [(30) 300、最长递增子序列](#30-300最长递增子序列)
    * [(31) 1143、最长公共子序列](#31-1143最长公共子序列)
    * [(32) 1035、不相交的线](#32-1035不相交的线)
  * [5\.2 子序列连续 <a href="\./README\.md">↑</a>](#52-子序列连续-)
    * [(33) 674、最长连读递增序列](#33-674最长连读递增序列)
    * [(34) 718、最长重复子数组](#34-718最长重复子数组)
    * [(35) 53、最大子序和](#35-53最大子序和)
  * [5\.3 编辑距离 <a href="\./README\.md">↑</a>](#53-编辑距离-)
    * [(36) 392、判断子序列](#36-392判断子序列)
    * [(37) 115、不同的子序列](#37-115不同的子序列)
    * [(38) 583、两个字符串的删除操作](#38-583两个字符串的删除操作)
    * [(39) 72、编辑距离](#39-72编辑距离)
  * [5\.4 回文 <a href="\./README\.md">↑</a>](#54-回文-)
    * [(40) 647、回文子串](#40-647回文子串)
    * [(41) 516、最长回文子序列](#41-516最长回文子序列)
      
### 一、有关数组的题目  [↑](./README.md)
### 1、 二分查找法的应用 [↑](./README.md)

#### （1）704. 二分查找 

题目链接：https://leetcode-cn.com/problems/binary-search/

**C++：**
```C++
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};

```


```C++
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```



#### 其他语言版本

**Java：**

（版本一）左闭右闭区间

```java
class Solution {
    public int search(int[] nums, int target) {
        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }
}
```

（版本二）左闭右开区间

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid;
        }
        return -1;
    }
}
```

**Python：**

（版本一）左闭右闭区间

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            middle = (left + right) // 2

            if nums[middle] < target:
                left = middle + 1
            elif nums[middle] > target:
                right = middle - 1
            else:
                return middle
        return -1
```

（版本二）左闭右开区间

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left,right  =0, len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid+1
            elif nums[mid] > target:
                right = mid
            else:
                return mid
        return -1
```



#### （2）35. 搜索插入位置

题目链接：https://leetcode-cn.com/problems/search-insert-position/

**Java版本：**
（版本一）左闭右闭区间
```Java
class Solution {
    public int searchInsert(int[] nums, int target) {
     int n = nums.length;
     int left = 0,right=n-1;
     int ans = n;
     //如果不存在数组中，将返回按顺序插入的位置pos
     //则有 nums[pos-1]<target<=nums[pos]
     //也就是遍历有序数组，找到第一个大于等于target的pos值即可，使用二分法
     //此时为左区间闭，右区间闭的情况
     while(left<=right){
         int mid = ((right-left)>>1)+left;//防止溢出
         if(nums[mid]>=target){//每次循环，逐次逼近第一个大于等于target的mid值,此时的mid值便是pos值，也就是target将要插入的位置
             ans = mid;
             right = mid -1;//[left,right]->[left,mid-1],说明
         }
         else{
             left = mid+1;//[left,right]->[mid+1,right]
         }
    
     }
     return ans;
    }
}

```
（版本二）左闭右开区间
```Java
class Solution {
    public int searchInsert(int[] nums, int target) {
     int n = nums.length;
     int left = 0,right=n;
     int ans = n;
     //如果不存在数组中，将返回按顺序插入的位置pos
     //择优 nums[pos-1]<target<=nums[pos]
     //也就是遍历有序数组，找到第一个大于等于target的pos值即可，使用二分法
     //此时为左区间闭，右区间开的情况
     while(left<right){
         int mid = ((right-left)>>1)+left;//防止溢出
         if(nums[mid]>=target){//每次循环，逐次逼近第一个大于等于target的mid值,此时的mid值便是pos值，也就是target将要插入的位置
             ans = mid;
             right = mid;//[left,right)>[left,mid)
         }
         else{
             left = mid+1;//[left,right)->[mid+1,right)
         }
    
     }
     return ans;
    }
}
```

**Python版本**
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        n = len(nums)
        left,right,ans=0,n-1,n

        while left<=right:
            mid = (right+left)//2
            if nums[mid]>=target:
                ans=mid
                right=mid-1
            else:
                left=mid+1
        return ans                       
             
```

#### （3）34.在排序数组中查找元素的第一个和最后一个位置

题目链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/


**Java：**
```Java
class Solution {
    //分析题目，可以得到，
    //Leftidx满足:nums[leftIdx-1]<target<=nums[leftIdx],代表第一个等于target的位置
    //rightIdx满足：nums[rightIdx]<=target<nums[rightIdx+1],代表第一个大于target的位置-1
    public int[] searchRange(int[] nums, int target) {
        int leftIdx = binarySearch(nums, target, true);//输出第一个等于target的位置
        int rightIdx = binarySearch(nums, target, false) - 1;//输出第一个大于target的位置-1
        if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {
            return new int[]{leftIdx, rightIdx};
        } 
        return new int[]{-1, -1};
    }

    //二分查找法，输入，Nums数组，target,
    //lower=true表示nums[mid] >= target,此时循环判断输出为第一个等于target的位置
    //lower=false表示nums[mid] > target，此时循环判断输出为第一个大于target的位置
    public int binarySearch(int[] nums, int target, boolean lower) {
        int left = 0, right = nums.length - 1, ans = nums.length;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```
**Python版本**
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        n=len(nums)
        def binarySearch(nums,target,flag):
            left,right,ans=0,n-1,n
            while left<=right:
                mid=(left+right)//2
                if (nums[mid]>target)or(flag and nums[mid]>=target):
                    ans=mid
                    right=mid-1
                else:
                    left=mid+1
            return ans

        leftindex=binarySearch(nums,target,flag=True)
        rightindex=binarySearch(nums,target,flag=False)-1
        if leftindex<=rightindex and nums[leftindex]==target and nums[rightindex]==target:
            return [leftindex,rightindex]
        else:
            return [-1,-1]  
```


#### （4）69.x的平方根

题目链接：https://leetcode-cn.com/problems/sqrtx/submissions/

**f方法一：二分查找法**
```Java
class Solution {
    public int mySqrt(int x) {
     //在0-x的整数中寻找一个数，它是的平方是最大的小于等于x的值
     int left = 0, right = x;
     int res = x;
    while(left<=right){
        int mid = left+((right-left)>>2);
        if(（long）mid*mid<=x){//long防止x的值大于Integer.MAX_VALUE
           res = mid;
           left = mid +1;
        }else{
           right = mid -1;
        }
    }
    return res;
    }
}
```
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        left,right,ans=0,x,x
        while left<=right:
            mid=(left+right)//2
            if mid*mid<=x:
                ans=mid
                left=mid+1
            else:
                right=mid-1
        return ans           
···
        

**方法二：牛顿迭代法**

```Java
class Solution {
    public int mySqrt(int x) {
        if(x==0)
         return 0;
         double C=x,x0=x;
         while(true){
             double xi = 0.5*(x0+C/x0);
             if(Math.abs(x0-xi)<1e-7){
                 break;
             } 
             x0 = xi;
         }
        
        return (int)x0;
    }
}
```
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x==0:
            return x
        C,x0=x,x
        while(True):
            x1 = 0.5*(x0+C/x0)
            if abs(x0-x1)<1e-7:
                break
            x0=x1
        return int(x0)        
```        
        
       

#### （5）367.有效的完全平方数

题目链接：https://leetcode-cn.com/problems/valid-perfect-square/submissions/


**方法一：二分查找法**
```Java
class Solution {
    public boolean isPerfectSquare(int num) {
      //在0-num中，使用二分查找法，查找一个数的平方等于Num
      int left =0,right=num,res=-1;
      while(left<=right){
          int mid = left+((right-left)>>2);
          if((long)mid*mid>num){
              right = mid-1;
          }else if(mid*mid<num){
              left = mid+1;
          }else{
             return true;
          }
      }
      return false;
    }
}
```
```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left,right=0,num
        while left<=right:
            mid=(left+right)//2
            if mid*mid>num:
                right=mid-1
            elif mid*mid<num:
                left=mid+1
            else:
                return True
        return False                
```

**方法二：牛顿迭代法**
```Java
class Solution {
    public boolean isPerfectSquare(int num) {
      //使用牛顿迭代法，快速逼近平方根数，如果这个数存在，则返回true，否则false
    
      if(num<2){//num=0,1都是完全平方数
          return true;
      }
      long C = num,x0 = num/2;
      while(x0*x0>num){//循环的跳出条件是x0*x0<=num
         long xi = (x0+C/x0)/2;
          x0 = xi;
      }
      return (x0*x0==num);
    }
}
```
```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num<2:
            return True
        C,x0=num,num//2
        while x0*x0>num:
            x1=(x0+C/x0)//2
            x0=x1
        return x0*x0==num    
 ```



### 2、 移除元素 [↑](./README.md)

#### （6）27.移除元素

题目链接：https://leetcode-cn.com/problems/remove-element/submissions/

```Java
class Solution {
    public int removeElement(int[] nums, int val) {
     //双指针法，遍历数组，如果快指针指向的数字==val，此时快指针加一，否则慢指针加一
     int n = nums.length;
     if(n==0)
       return 0;
     int slow = 0,fast = 0;
     while(fast<n){
         if(nums[fast]!=val){
             nums[slow]=nums[fast];
             slow++;
         }
         fast++;
     } 
     return slow; 
    }
}
```

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        if len(nums)==0:
            return 0
        slow,fast=0,0
        while(fast<len(nums)):
            if nums[fast]!=val:
                nums[slow]=nums[fast]
                slow +=1
            fast+=1
        return slow
 ```

#### （7）26.删除有序数组中的重复项

题目链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/submissions/

```Java
class Solution {
    public int removeDuplicates(int[] nums) {
      //双指针
      int n = nums.length;
      int slow =1,fast=1;
      while(fast<n){
          if(nums[fast]!=nums[fast-1]){
              nums[slow] = nums[fast];
              slow++;
          }
          fast++;
      }
      return slow;
    }
}
```

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums)==0:
            return 0
        slow,fast=1,1
        while fast<len(nums):
            if nums[fast]!=nums[fast-1]:
                nums[slow]=nums[fast]
                slow+=1
            fast+=1
        return slow      
           
```


#### （8）283.移动零

题目链接：https://leetcode-cn.com/problems/move-zeroes/

```Java
class Solution {
    public void moveZeroes(int[] nums) {
     int n = nums.length;
     //双指针，去除0，之后再加上0
     int slow = 0,fast = 0;
     while(fast<n){
         if(nums[fast]!=0){
             nums[slow] = nums[fast];
             slow++;
         }
         fast++;
     }
    for(int i=slow;i<n;i++){
        nums[i] = 0;
    }
  
    }
}
```
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n=len(nums)
        slow,fast=0,0
        while fast<n:
            if nums[fast]!=0:
                nums[slow]=nums[fast]
                slow+=1
            fast+=1
        for i in range(slow,n):
            nums[i]=0
```


#### （9）844.比较含退格的字符串

题目链接：https://leetcode-cn.com/problems/backspace-string-compare/submissions/

**方法一：重构字符串**
```Java
class Solution {
    public boolean backspaceCompare(String s, String t) {
    //双指针，去除空格后比较
    return build(s).equals(build(t));
    }

    //输入字符串，输出删除空格后的字符串
    public String build(String str){
        StringBuffer ret = new StringBuffer();
        int length = str.length();
        for(int i=0;i<length;i++){
            char ch = str.charAt(i);
            if(ch!='#'){
                ret.append(ch);
            }else{
                if(ret.length()>0){
                    ret.deleteCharAt(ret.length()-1);
                }
            }
        }
        return ret.toString();
    }
}
```

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def build(s:str)->str:
            res=list()
            for ch in s:
                if ch!='#':
                    res.append(ch)
                elif res:
                    res.pop()
            return "".join(res)
        return build(s)==build(t)                
```
**方法二：双指针**

```Java
class Solution {
    public boolean backspaceCompare(String s, String t) {
      //使用双指针
/*一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。
具体地，我们定义skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：
若该字符为退格符，则我们需要多删除一个普通字符，我们让skip 加 1；
若该字符为普通字符：
若 skip 为 0，则说明当前字符不需要删去；
若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1。
这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，
然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。
 */

    int i=s.length()-1,j=t.length()-1;
    int skipS = 0,skipT = 0;//skip代表当前待删除的字符串的数量，逆序遍历，如果遇到退格符，则加1
     while(i>=0||j>=0){
         //如果s字符串遍历结束
         while(i>=0){
             if(s.charAt(i)=='#'){
                 skipS++;//如果遇到退格，加一
                 i--;//向前遍历
             }else if(skipS>0){
                 //如果遇到字符串，且skipS大于0，说明字符串前面有退格，表示该字符串将被删去
                 //此时删去字符，skipS--
                 skipS--;
                 i--;
             }else{
                 break;
             }
         }
 
         //同理，如果t字符串遍历结束
         while(j>=0){
             if(t.charAt(j)=='#'){
                 skipT++;
                 j--;
             }else if(skipT>0){
                 skipT--;
                 j--;
             }else{
                 break;
             }
         }

         //如果s和t字符串同时遍历结束
         if(i>=0 && j>=0){
             //比较这两个字符串所对应位置的字符
             //如果有不同的字符，则需要返回false
             if(s.charAt(i)!=t.charAt(j))
             return false;
         }else{
             //如果其中有字符串遍历结束，返回false;
             if(i>=0||j>=0){
                 return false;
             }
         }
         i--;
         j--;

     }
     return true;//如果在上面循环中没有返回false,则说明两个字符串相等

    }
}
```

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        i,j=len(s)-1,len(t)-1
        skipS=skipT=0
        while i>=0 or j>=0:
            while i>=0:
                if s[i]=="#":
                    skipS+=1
                    i-=1
                elif skipS>0:
                    skipS-=1
                    i-=1
                else:
                    break
            while j>=0:
                if t[j]=="#":
                    skipT+=1
                    j-=1
                elif skipT>0:
                    skipT-=1
                    j-=1
                else:
                    break
            if i>=0 and j>=0:
                if s[i]!=t[j]:
                    return False
            elif i>=0 or j>=0:
                return False
            i-=1
            j-=1
        return True

```

#### （10）977.有序数组的平方

题目链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/

**方法一：使用归并排序法**
```Java
class Solution {
    public int[] sortedSquares(int[] nums) {
     //数组中有负数和正数
     //负数的平方，排序为降序，正数的平方排序为升序
     //两个有序数组，使用归并排序即可
    int n = nums.length;
     //第一步，先找到正数和负数的分界线nums[neg]  
     //nums[0]-nums[neg]<0 nums[neg+1]-nums[n-1]>0
     int neg = -1;//初始化为-1
     for(int i=0;i<n;i++){
         if(nums[i]<0){
             neg = i;//找到分界点
         }else{
             break;
         }
     }
     //第二步，对两个有序数组进行归并排序
     //负数的平方组成的有序数组从nums[0]-nums[neg]，这是降序排列的 nums[neg]-nums[0]是负数平方的升序排列
     //正数的平方组成的有序数组从nums[neg+1]-nums[n-1]
     //指针i指向负数升序排列的第一个，指针j指针正数升序排列的第一个，比较两者的大小，较小的放入ans[]数组中
     int[] ans = new int[n];
     int index =0,i=neg,j=neg+1;
      while(i>=0||j<n){//i降序，每次循环减一，下限为0，j升序，每次循环加一，上限为n
        if(i<0){//i<0表示原数组没有负数，全部是正数，此时直接讲nums[j]平方即可
            ans[index] = nums[j]*nums[j];
            j++;
        }else if(j==n){//j=n表示原数组没有正数，全市负数，i从最小的负数开始遍历，此时nums[i]的平方是最小的，i--，nums[i]的平方增加
            ans[index] = nums[i]*nums[i];
            i--;
        }else if(nums[i]*nums[i]<nums[j]*nums[j]){//此时表示原数组，正负数都存在，取两个有序数组中最小的放入新数组中
           ans[index] = nums[i]*nums[i];
           i--;
        }else{
            ans[index] = nums[j]*nums[j];
            j++;
        }

        index++;//每次循环，新数组中增加一个平方数

      }
      return ans;
    }
}
```

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n=len(nums)
        neg=-1
        #计算得到正负数的分界点
        for i in range(0,n):
            if nums[i]<0:
                neg=i
            else:
                break
        ans=[0]*n
        index,i,j=0,neg,neg+1
        while i>=0 or j<n:
            if i<0:#说明没有负数
               ans[index]=nums[j]**2
               j+=1
            elif j==n:#说明没有正数
               ans[index]=nums[i]**2
               i-=1
            elif nums[i]**2<nums[j]**2:
               ans[index]=nums[i]**2
               i-=1
            else:
               ans[index]=nums[j]**2
               j+=1
            index+=1
        return ans      
```        
**方法二：使用左右指针法**

```Java
class Solution {
    public int[] sortedSquares(int[] nums) {
     //双指针法
     //平方后的数组最大值，或者在最右端或者在最左端
     //考虑使用双指针，一个指向起始位置，一个指向终止位置
     int right = nums.length-1;
     int left = 0;
     int[] res = new int[nums.length];
     int index = res.length-1;

     while(left<=right){
         if(nums[left]*nums[left]>nums[right]*nums[right]){
             res[index--] = nums[left]*nums[left];
             left++;
         }else{
             res[index--] = nums[right]*nums[right];
             right--;
         }
     }
     return res;
    }
}
```

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        #左右指针
        n=len(nums)
        left,right,index=0,n-1,n-1
        res=[0]*n

        while left<=right:
            if nums[left]**2>nums[right]**2:
                res[index]=nums[left]**2
                index-=1
                left+=1
            else:
                res[index]=nums[right]**2
                index-=1
                right-=1
        return res            
```


### 3、滑动窗口 [↑](./README.md)

#### （11）209.长度最小的数组

题目链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum/submissions/

**使用滑动窗口法**

C++版本
```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
    int result = INT32_MAX;
    int sum = 0;//滑动窗口的数值之和
    int i = 0;//活动窗口的起始位置
    int sublength = 0;//滑动窗口的长度
    for(int j=0;j<nums.size();j++){
        sum += nums[j];
        //这里使用while，每次更新i起始位置，并不断比较子序列是否符合条件
        while(sum>=target){
            sublength = (j-i+1);//取子序列的长度
            result = result<sublength ? result : sublength;
            sum -= nums[i++];//这是体现滑动窗口的精髓，不断变更i的位置
        }
        
    }
    //如果result没有被赋值的话，返回0，否则返回符合条件的最小子序列
    return result == INT32_MAX ? 0: result;
    }
};
```

Java版本

```Java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
      int n = nums.length;
      int res = Integer.MAX_VALUE;
      int i = 0,sum =0,subLength = 0;
      for(int j = 0;j<n;j++){
        sum += nums[j];
        while(sum>=target){
          subLength = (j-i+1);//获取子序列的长度
          res = res<subLength ? res:subLength;
          sum -= nums[i++];//体现了滑动窗口的精髓，每次更新i的位置
        }
      }
      return res == Integer.MAX_VALUE ? 0 :res;
    }
}
```

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n=len(nums)
        res,i,Sum,sublen=n+1,0,0,0
        for j in range(0,n):
            Sum+=nums[j]
            while Sum>=target:
                sublen=j-i+1
                res= res if res<sublen else sublen
                Sum-=nums[i]
                i+=1
        return 0 if res==n+1 else res    
```
#### （12）904.水果成篮

题目链接 ：https://leetcode-cn.com/problems/fruit-into-baskets/submissions/

**滑动窗口+哈希表**

```Java
class Solution {
    public int totalFruit(int[] tree) {
     int n = tree.length;//树的长度
     int res =0,i = 0;//res是窗口的长度，i是起始位置
     Counter count = new Counter();//新创建了衣蛾count类，重写了add和get方法
     for(int j=0;j<n;j++){//j代表窗口的终止位置
         count.add(tree[j],1);//将第一个树的类型，对应的value=1放入mao中
         while(count.size()>=3){//当时counte中的种类超过2时，跳出循环，比较大小
             count.add(tree[i],-1);//将起始位置i的类型，对应的value=-1，加入counter中
             if(count.get(tree[i])==0){//如果value等于0，有重复的类型，删去上一个类型
               count.remove(tree[i]);
            }
            i++;//起始位置加一
         }
         res = res> j-i+1 ? res : j-i+1; //返回最大致
     }
     return res;
    }


//Counter类继承了HashMap，key值不可重复，如果重复覆盖前一个值
class Counter extends HashMap<Integer,Integer>{
    //重写了get方法，如果Map存在k，则返回k对应的value值，,否则返回0，也就是不存在
    public int get(int k){
        return containsKey(k)?super.get(k):0;
    }

    //重写add方法，将key 和 key对应的value + v之和得值放入新的key,value中
    public void add(int k,int v){
        put(k,get(k)+v);
    }
}
}

```

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        ans=i=0
        count=collections.Counter()
        for j,x in enumerate(fruits):
            count[x]+=1
            while len(count)>=3:
                count[fruits[i]]-=1
                if count[fruits[i]]==0:
                    del count[fruits[i]]
                i+=1
            ans=max(ans,j-i+1)
        return ans            
  ```      

#### （13）76.最小覆盖子串

题目链接：https://leetcode-cn.com/problems/minimum-window-substring/

```Java
class Solution {
     //使用滑动窗口
     //借助哈希表
     Map<Character,Integer> ori = new HashMap<Character,Integer>();
     Map<Character,Integer> cnt = new HashMap<Character,Integer>();

     public String minWindow(String s, String t){
         int tLen = t.length();
         //将t字符创存入哈希表中，key对应字符，value对应字符出现的次数，返回ori哈希表
         for(int i=0;i<tLen;i++){
             char c = t.charAt(i);
             //getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。

             ori.put(c,ori.getOrDefault(c,0)+1);
         }   
    //双指针，l用于收缩窗口，r用于延伸窗口 窗口的位置[l,r]
     int l = 0,r=-1;
     //初始化最小窗口的长度len,左边窗口的位置ansL,右边窗口的位置ansR
     int len = Integer.MAX_VALUE,ansL = -1,ansR = -1;
     int slen = s.length();
     //延伸指针循环遍历s字符创
     while(r<slen){
         //每次循环r增加一
         ++r;
         //如果延伸指针在字符创长度内，并且s字符串该位置对应的字符，在t字符哈希表中
         if(r<slen && ori.containsKey(s.charAt(r))){
            //cnt用于存储所有包含t字符的字符串
            //将s字符串对应的该位置r的对应字符，以及字符出现的次数放入cnt哈希表中
             cnt.put(s.charAt(r),cnt.getOrDefault(s.charAt(r),0)+1);
         }
         //check用于判断cnt中字符出现的次数是不是小于ori中对应字符出现的次数
         while(check() && l<=r){
             //r-l+1为滑动窗口的长度
             if(r-l+1<len){
                 len = r-l+1;//子字符串的最小长度为len
                 ansL = l;//子字符串窗口的左边位置
                 ansR = l+len;//子字符串窗口的右边位置
             }
             //如果ori总共包含子字符串最左边的字符
             if(ori.containsKey(s.charAt(l))){
                 //收缩窗口
                 //cnt哈希表中最左边的字符所对应的次数减一，表示窗口向右滑动
                 cnt.put(s.charAt(l),cnt.getOrDefault(s.charAt(l),0)-1);
             }
             //窗口的起始位置每次循环加一
             ++l;
         }
     }
     //如果ansl没有变化，说明s字符串不包含涵盖t字符串的子串，返回空串，否则返回子串
     return ansL == -1?"":s.substring(ansL,ansR);

     }
 
    //判断cnt中字符出现的次数是不是小于ori中对应字符出现的次数
    public boolean check(){
        //entrySet()返回set视图，诸如[1=Google, 2=Runoob, 3=Taobao]
        //iterator()获取Set视图的迭代器，用于每次循环使用
        Iterator iter = ori.entrySet().iterator();
        //循环HashMap,如果map存在元素
        while(iter.hasNext()){
            //Map.Entry是Map的一个内部接口,具有getKey(),getValue()方法
            Map.Entry entry = (Map.Entry) iter.next();
            //返回key值
            Character key = (Character) entry.getKey();
            //返回val值
            Integer val = (Integer)entry.getValue();
            //如果滑动窗口哈希表中对应的字符出现的次数小于t字符串哈希表中的出现的次数，返回false,否则为true
            if(cnt.getOrDefault(key,0)<val){
                return false;
            }
        }
        return true;
    }

 }
 ```
 
 ```python
 def minWindow(self, s: str, t: str) -> str:
        need=collections.defaultdict(int)
        for c in t:
            need[c]+=1
        needCnt=len(t)
        i=0
        res=(0,float('inf'))
        for j,c in enumerate(s):
            if need[c]>0:
                needCnt-=1
            need[c]-=1
            if needCnt==0:       #步骤一：滑动窗口包含了所有T元素
                while True:      #步骤二：增加i，排除多余元素
                    c=s[i] 
                    if need[c]==0:
                        break
                    need[c]+=1
                    i+=1
                if j-i<res[1]-res[0]:   #记录结果
                    res=(i,j)
                need[s[i]]+=1  #步骤三：i增加一个位置，寻找新的满足条件滑动窗口
                needCnt+=1
                i+=1
        return '' if res[1]>len(s) else s[res[0]:res[1]+1]    #如果res始终没被更新过，代表无满足条件的结果
```

### 4、螺旋矩阵 [↑](./README.md)

#### （14）59、螺旋矩阵II

题目链接：https://leetcode-cn.com/problems/spiral-matrix-ii/submissions/


```Java
class Solution {
    public int[][] generateMatrix(int n) {
     int[][] res = new int[n][n];
     int offset = 1;//控制每一圈循环的长度
     int startX = 0;//初始化行
     int startY = 0;//初始化列
     int num = 1;//初始化填充数字
     int mid = n/2;//中间需要填充数字的位置
     int loop = n/2;//需要循环的圈数
     while(loop>0){

         int i = startX;
         int j = startY;

         //上，从左到右
         for(;j<startY+n-offset;j++){
             res[startX][j] = num++;
         }
         //右侧，从上到下
         for(;i<startX+n-offset;i++){
             res[i][j] = num++;
         }
         //下侧，从右到左
         for(;j>startY;j--){
             res[i][j] = num++;
         }
         //左侧，从下到上
         for(;i>startX;i--){
             res[i][j] = num++;
         }

         startX++;
         startY++;

         offset += 2;
         loop--;

     }
    //如果n为奇数，中间的值需要另外填充
     if(n%2==1){
         res[mid][mid] = num;
     }
     return res;
    }
}
```

#### （15）54、螺旋矩阵

题目连接：https://leetcode-cn.com/problems/spiral-matrix/submissions/

```Java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
     //按层模拟
     //首先输出最外层，其次输出次外层，最后输出最内层
     //对于每层，从左上方开始顺时针遍历
     //上：
     List<Integer> order = new ArrayList<Integer>();
     if(matrix==null || matrix.length==0 || matrix[0].length==0){
         return order;//判断非空条件
     }

     int rows = matrix.length;
     int cols = matrix[0].length;

     int left = 0,right = cols-1,top = 0,bottom = rows-1;
     while(left<=right && top<=bottom){
         //最上侧，从左往右  
         for(int col=left;col<=right;col++){
          order.add(matrix[top][col]);
         }
         //最右侧，从上到下
         for(int row = top+1;row<=bottom;row++){
             order.add(matrix[row][right]);
         }
         //如果left<right且top<bottom,则从右到左，遍历下面元素
         if(left<right && top<bottom){
             //则从右到左，遍历下面元素
             for(int col = right-1;col>left;col--){
              order.add(matrix[bottom][col]);
             }
             //从下到上，遍历左侧元素
             for(int row=bottom;row>top;row--){
                 order.add(matrix[row][left]);
             }

         }

         left++;
         right--;
         top++;
         bottom--;
     }
     return order;

    }
}
```

```python
class Solution:
    def spiralOrder(matrix):
        if not matrix or not matrix[0]:
            return list()
        rows,colums=len(matrix),len(matrix[0])
        visited=[[False]*colums for _ in range(rows)]#辅助矩阵，标记该位置是否已经被访问过
        total = rows*colums
        order=[0]*total

        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 控制顺时针旋转
        r,c,dirIdx=0,0,0
        for i in range(total):
            order[i]=matrix[r][c]
            visited[r][c]=True
            dx,dy=dirs[dirIdx]
            nextR,nextC=r+dx,c+dy
            if nextR<0 or nextR>=rows or nextC<0 or nextC>=colums or visited[nextR][nextC]:
                dirIdx=(dirIdx+1)%4
                dx, dy = dirs[dirIdx]
            r,c=r+dx,c+dy
        return order
```        

#### （16）29、顺时针打印矩阵

题目连接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/submissions/

```Java

class Solution {
    public int[] spiralOrder(int[][] matrix) {
        //判断非空条件
        if(matrix==null || matrix.length==0 || matrix[0].length ==0){
            return new int[0];
        }

        int rows  = matrix.length;//矩阵的行数
        int cols = matrix[0].length;//矩阵的列数

        int [] res = new int[rows*cols];//存储遍历值的矩阵

        int n = 0;//需要填充的位置
        int left=0,right=cols-1,top=0,bottom=rows-1;
        
        while(left<=right && top<=bottom){
            //上侧，从左到右
            for(int col = left;col<=right;col++){
                res[n++] = matrix[top][col];
            }
            //右侧，从上到下
            for(int row = top+1;row<=bottom;row++){
                res[n++] = matrix[row][right];
            }

            //判断left<right和top<bottom
            if(left<right && top<bottom){
                //下侧，从右到左
                for(int col = right-1;col>left;col--){
                    res[n++] = matrix[bottom][col];
                }
                //左侧，从下到上
                for(int row = bottom;row>top;row--){
                    res[n++] = matrix[row][left];
                }
            }

            left++;
            top++;
            right--;
            bottom--;
        }
        return res;
    }
}
```

```python
class Solution:
    def spiralOrder(matrix):
        if not matrix or not matrix[0]:
            return list()
        rows,colums=len(matrix),len(matrix[0])
        visited=[[False]*colums for _ in range(rows)]#辅助矩阵，标记该位置是否已经被访问过
        total = rows*colums
        order=[0]*total

        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 控制顺时针旋转
        r,c,dirIdx=0,0,0
        for i in range(total):
            order[i]=matrix[r][c]
            visited[r][c]=True
            dx,dy=dirs[dirIdx]
            nextR,nextC=r+dx,c+dy
            if nextR<0 or nextR>=rows or nextC<0 or nextC>=colums or visited[nextR][nextC]:
                dirIdx=(dirIdx+1)%4
                dx, dy = dirs[dirIdx]
            r,c=r+dx,c+dy
        return order
```        
        
        


## 二、链表 [↑](./README.md)

### （1）203.移除俩表
题目链接：https://leetcode-cn.com/problems/remove-linked-list-elements/submissions/

 ``` Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //判断链表非空
        if(head==null){
            return head;
        }

        //借助虚拟节点
        ListNode dummy = new ListNode(-1,head);
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur!=null){
            if(cur.val==val){
                pre.next = cur.next;
            }else{
                pre = cur;
            }
            cur = cur.next;
        }
        return dummy.next;
    }
}
```

```python
class Solution:
    def removeElements(head:ListNode,val:int):
        dummy=ListNode(0)
        dummy.next=head
        p=dummy
        while p is not None:
            if p.next and p.next.value == val:
                p.next=p.next.next
            else:
                p=p.next
        return dummy.next
```        

### （2）707、设计链表

题目链接:https://leetcode-cn.com/problems/design-linked-list/submissions/

```Java
class MyLinkedList {

    int size;//初始化链表的元素
    ListNode head;//虚拟化头结点
    /**初始化链表 */
    public MyLinkedList() {
      size = 0;
      head = new ListNode(0);

    }
    
    /** 获取链表中第 index 个节点的值。如果索引无效，则返回-1 */
    public int get(int index) {
      if(index>=size || index<0){
          return -1;
      }
      ListNode cur = head;
      for(int i=0; i<=index; i++){
          cur = cur.next;
      }
      return cur.val;
    }
    
    /** 在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点 */
    public void addAtHead(int val) {
      addAtIndex(0,val);
    }
    
    /**将值为 val 的节点追加到链表的最后一个元素 */
    public void addAtTail(int val) {
      addAtIndex(size,val);
    }
    
    /** 在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点 */
    public void addAtIndex(int index, int val) {
     if(index>size){
         return;
     }
     if(index<0){
         index = 0;
     }
     size++;
     ListNode cur = head;
     for(int i=0;i<index;i++){
         cur = cur.next;
     }
     ListNode add = new ListNode(val);
     add.next = cur.next;
     cur.next = add;
    }
    
    /** 如果索引 index 有效，则删除链表中的第 index 个节点 */
    public void deleteAtIndex(int index) {
    if(index>=size ||index<0){
        return;
    }
    size--;
    ListNode cur = head;
    for(int i=0;i<index;i++){
        cur = cur.next;
    }
     cur.next = cur.next.next;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
 ```
 
 ```python
 class MyLinkedList:

    def __init__(self):
        """
        初始化链表
        """
        self.size=0
        self.head=ListNode(0)


    def get(self, index: int) -> int:
        """
       得到第index位置的值
        """
        if index<0 or index>=self.size:
            return -1
        curr=self.head
        for _ in range(index+1):
            curr=curr.next
        return curr.val



    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        """
        self.addAtIndex(0,val)


    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self.addAtIndex(self.size,val)


    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        """
        if index>self.size:
            return

        if index<0:
            index=0

        self.size+=1
        pred=self.head
        for _ in range(index):
            pred=pred.next

        to_add=ListNode(val)
        to_add.next=pred.next
        pred.next=to_add


    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if index<0 or index>self.size:
            return
        self.size-=1
        pred=self.head
        for _ in range(index):
            pred=pred.next

        pred.next=pred.next.next
```        
 
 ### (3) 206、反转链表
 题目链接：https://leetcode-cn.com/problems/reverse-linked-list/
 
 
 ```Java
 //双指针法
 class Solution {
    public ListNode reverseList(ListNode head) {
    ListNode tmp = null;
    ListNode pre = null;
    ListNode cur = head;
    while(cur!=null){
        tmp = cur.next;//保存下一个节点
        cur.next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;

    }
}
```

```python
class Solution:
    def reverseList(head):
        pre=None
        cur=head
        while cur:
            tmp=cur.next
            cur.next=pre
            pre=cur
            cur=tmp
        return pre
```




### (4) 24、两两交换链表中的节点
题目链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;

        while(pre.next!=null && pre.next.next!=null){
            ListNode tmp1 = pre.next.next.next;
            ListNode tmp2 = pre.next;

            //步骤一
            pre.next = pre.next.next;
            //步骤二
            pre.next.next = tmp2;
            //步骤三
            pre.next.next.next = tmp1;

            //移动两位，进行下一步循环
            pre = pre.next.next;
        }

        return dummy.next;

    }
}
 
```

```python
class Solution:
    def swapPairs(head:ListNode)->ListNode:
        dummy=ListNode(0)
        dummy.next=head
        pre=dummy

        while pre.next and pre.next.next:
            tmp1=pre.next.next.next
            tmp2=pre.next

            #步骤一
            pre.next=pre.next.next
            #步骤二
            pre.next.next=tmp2
            #步骤三
            pre.next.next.next=tmp1

            #移动两位,进行下一步循环
            pre=pre.next.next

        return dummy.next
```


### (5) 19、删除链表中倒数第N个节点
题目链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
     //定义虚拟化头结点
     ListNode dummy = new ListNode(0);
     dummy.next = head;
     ListNode slow = dummy;//初始化慢指针
     ListNode fast = dummy;//初始化快指针

     //先将快指针移动n+1步
     while(n-->0){
         fast = fast.next;
     }
     //之后，快慢指针一起移动，直到快指针指向Null,此时慢指针指向的节点是要删除节点的上一个节点
     ListNode pre = null;
     while(fast!=null){
       pre = slow;
       slow = slow.next;
       fast = fast.next;
     }

     pre.next = slow.next;//删除节点

     return dummy.next;
    }
 ```
 
 ```python
 class Solution:
    def removeNthFromEnd(head:ListNode,n:int)->ListNode:
        #定义虚拟头节点
        dummy=ListNode(0)
        dummy.next=head
        slow=dummy#定义慢指针
        fast=dummy#定义快指针

        #快指针先移动n+1步
        while n>0:
            fast=fast.next
            n-=1

        #之后快慢指针一起移动
        #直到快指针指向NULL,此时 慢指针指向的节点是要删除节点的上一个节点
        pre=ListNode(None)
        while fast:
            pre=slow
            slow=slow.next
            fast=fast.next

        pre.next=slow.next#删除节点
        return dummy.next
```
 
 
 ### (6) 142.环形链表
 
 题目链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/
 
 ```Java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;

        //快指针走两步，慢指针走一步，两者相遇，即是有环
        while(fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow==fast){//如果有环
             ListNode index1 = fast;
             ListNode index2 = head;
             //两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口
             while(index1!=index2){
                 index1 = index1.next;
                 index2 = index2.next;
             }
             return index1;//或者 return index2
            }
        }
        return null;
    }
}
```

```python
class Solution:
    def detectCycle(head:ListNode)->ListNode:
        slow,fast=head,head#定义快慢指针
        #快指针走两步，慢指针走一步，两者相遇即是有环
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if slow==fast:#此时表示有环的存在
                index1=fast
                index2=head
                #两个指针，从头结点和相遇节点，各走一步，直到相遇，相遇点即为环入口
                while index1!=index2:
                    index1=index1.next
                    index2=index2.next
                return index1
        return None
```

## 三、哈希表 [↑](./README.md)

### 1、异位词 [↑](./README.md)

#### （1）242、有效的字母异位词
题目链接:https://leetcode-cn.com/problems/valid-anagram/submissions/

```Java
class Solution {
    public boolean isAnagram(String s, String t) {
         //使用哈希表的方法
         int[] record = new int[26];

        //将s字符串中的每一个字符出现的次数，添加+1到数组中
         for(char c:s.toCharArray()){
             record[c-'a'] += 1;
         }
         //将t字符串中每一个字符出现的次数，添加-1到数组中
         for(char c:t.toCharArray()){
             record[c-'a'] -=1;
         }

         for(int i:record){
             //如果数组中次数都是0，说明两个字符串为异位词
             if(i!=0){
                 return false;
             }
         }
         return true;
    }
}
```

```python
class Solution:
    def isAnagram(s:str,t:str)->bool:
        record=[0]*26
        for i in range(len(s)):
            record[ord(s[i])-ord("a")]+=1
        for i in range(len(t)):
            record[ord(t[i])-ord("a")]-=1
        for i in range(26):
            if record[i]!=0:
                return False
        return True
```



#### （2）383、赎金信
题目链接：https://leetcode-cn.com/problems/ransom-note/

``` Java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
     //使用哈希表
     int[] record = new int[26];

     //添加ransdomNote
     for(char c:ransomNote.toCharArray()){
         record[c-'a'] += 1;
     }

     //添加magazine
     for(char c:magazine.toCharArray()){
         record[c-'a'] -= 1;
     }

     for(int i:record){
         //i>=1表示赎金信中有字符没有被杂志覆盖
         if(i>=1){
            return false;
         }
     }
     return true;
    }
}
```

```python
class Solution:
    def canConstruct(self,ransomNote:str,managine:str)->bool:
        n,m=len(ransomNote),len(managine)
        if n>m or n==0:
            return False
        rec=[0]*26
        for i in range(n):
            rec[ord(ransomNote[i])-ord("a")]+=1
        for i in range(m):
            rec[ord(managine[i])-ord("a")]-=1
        for i in range(26):
            if rec[i]>=1:
                return False
        return True
```


#### （3）49、字母异位词分组

题目链接：https://leetcode-cn.com/problems/group-anagrams/submissions/

```Java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
    Map<String,List<String>> map = new HashMap<String,List<String>>();
    for(String str:strs){
        int[] counts = new int[26];
        int length =str.length();
        for(int i=0;i<length;i++){
            counts[str.charAt(i)-'a']++;
        }
        //将每个出现次数大于0的字母和出现的次数按顺序拼接成字符串，作为哈希表的键值
        //比如“eat”的键值为“a1e1t1”    "tea"的键值为“a1e1t1”
        StringBuffer sb = new StringBuffer();
        for(int i=0;i<26;i++){
            if(counts[i]!=0){
                sb.append((char)('a'+i));
                sb.append(counts[i]);
            }
        }

        String key = sb.toString();
        //如果两者的键值相等，调用list.add叠加字符串1+字符串2，否则null+字符串3
        List<String> list = map.getOrDefault(key,new ArrayList<String>());
        list.add(str);
        map.put(key,list);
    }
    return new ArrayList<List<String>>(map.values());
     
    }
}
```

```python
class Solution:
    def groupAnagram(strs:List[str])->List[List[str]]:
        mp=collections.defaultdict(list)

        for st in strs:
            counts = [0]*26
            for ch in st:
                counts[ord(ch)-ord("a")]+=1
            mp[tuple(counts)].append(st)
        return list(mp.values())
```


#### (4) 438、找到字符串中所有字母异位词
题目链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/submissions/

```Java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
      int n = s.length(),m=p.length();
      List<Integer> res = new ArrayList<>();
      if(n<m) return res;
      //记录字母出现的次数
      int[] pCnt = new int[26];
      int[] sCnt = new int[26];
      for(int i=0;i<m;i++){
          pCnt[p.charAt(i)-'a']++;
          sCnt[s.charAt(i)-'a']++;
      }
      //如果两者相等，找到第一个异位词索引0
      if(Arrays.equals(sCnt,pCnt)){
          res.add(0);
      }
      //继续遍历s字符串索引为[m,n)的字母，在sCnt中每增加一个新字母，去除一个旧字母
      for(int i=m;i<n;i++){
          sCnt[s.charAt(i-m)-'a']--;
          sCnt[s.charAt(i)-'a']++;
          //如果相等，返回res中的索引值i-m+1
          if(Arrays.equals(sCnt,pCnt)){
              res.add(i-m+1);
          }
      }
      return res;
    }
}
```
```python
class Solution:
    def findAnagrams(s: str, p: str) -> List[int]:
        n,m,res=len(s),len(p),[]
        if n<m: return res
        pcnt=[0]*26
        scnt=[0]*26
        for i in range(m):
            pcnt[ord(p[i])-ord("a")]+=1
            scnt[ord(s[i])-ord("a")]+=1

        if pcnt==scnt:
            res.append(0)

        for i in range(m,n):
            scnt[ord(s[i-m])-ord("a")]-=1
            scnt[ord(s[i])-ord("a")]+=1
            if scnt==pcnt:
                res.append(i-m+1)

        return res
```
### 2、数组交集 [↑](./README.md)

#### （5）349、两个数组的交集
题目链接：https://leetcode-cn.com/problems/intersection-of-two-arrays/

```Java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
    if(nums1.length==0 || nums1==null || nums2==null || nums2.length==0){
        return new int[0];
    }

    //创建哈希Set
    Set<Integer> set1 = new HashSet<>();
    Set<Integer> res = new HashSet<>();

    //将Nums1数组放入set1中
    for(int i:nums1){
        set1.add(i);
    }

    //遍历Nums2数组，判断是否有相同的元素
    for(int n:nums2){
        if(set1.contains(n)){
            res.add(n);
        }
    }

    //把set转成数组
    int[] ans = new int[res.size()];
    int index = 0;
    for(int j:res){
        ans[index++] = j;
    }
    return ans;
    }
}
```

```python
class Solution:
    def intersection(nums1:List[int],nums2:List[int])->List[int]:
        result_set=set()
        set1=set(nums1)
        for num in nums2:
            if num in set1:
                result_set.add(num)
        return list(result_set)
```
  
  
  
### 3、快乐数 [↑](./README.md)

### （6）202、快乐数
题目链接：https://leetcode-cn.com/problems/happy-number/

```Java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
```

```python
class Solution:
    def isHappy(n:int)->bool:
        def get_next(n):
            total_sum=0
            while n>0:
                n,digit=divmod(n,10)
                total_sum+=digit**2
            return total_sum

        #方法一：哈希表
        # seen=set()
        # while n!=1 and n not in seen:
        #     seen.add(n)
        #     n=get_next(n)
        # return n==1

        #方法二：快慢指针
        slow=n
        fast=get_next(n)
        while fast!=1 and slow!=fast:
            slow=get_next(slow)
            fast=get_next(get_next(fast))
        return fast==1

```

### 4、数的和 [↑](./README.md)

### （7）1、两数之和
题目链接：https://leetcode-cn.com/problems/two-sum/
```Java
public int[] twoSum(int[] nums, int target) {
    int[] res = new int[2];
    if(nums == null || nums.length == 0){
        return res;
    }
    Map<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < nums.length; i++){
        int temp = target - nums[i];
        if(map.containsKey(temp)){
            res[1] = i;
            res[0] = map.get(temp);
        }
        map.put(nums[i], i);
    }
    return res;
}
```

```python
class Solution:
    def twoSum(nums:List[int],target:int)->List[int]:
        res=dict()
        for i,num in enumerate(nums):
            print("i=",i)
            print("num=",num)
            print("res=",res)
            if target-num in res:
                return [res[target-num],i]
            res[nums[i]]=i
        return []
```

### （8）454、四数相加II
题目链接：https://leetcode-cn.com/problems/4sum-ii/

```Java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int temp;
        int res = 0;
        //统计两个数组中的元素之和，同时统计出现的次数，放入map
        for (int i : nums1) {
            for (int j : nums2) {
                temp = i + j;
                if (map.containsKey(temp)) {
                    map.put(temp, map.get(temp) + 1);
                } else {
                    map.put(temp, 1);
                }
            }
        }
        //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数
        for (int i : nums3) {
            for (int j : nums4) {
                temp = i + j;
                if (map.containsKey(0 - temp)) {
                    res += map.get(0 - temp);
                }
            }
        }
        return res;
    }
}
```

```python
class Solution:
    def fourSumCount(nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        countAB=collections.Counter(u+v for u in nums1 for v in nums2)
        ans=0
        for u in nums3:
            for v in nums4:
                if -u-v in countAB:
                    ans+=countAB[-u-v]
        return ans
```

### (9) 15、三数之和
题目链接：https://leetcode-cn.com/problems/3sum/

```Java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                return result;
            }

            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            int left = i + 1;
            int right = nums.length - 1;
            while (right > left) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    
                    right--; 
                    left++;
                }
            }
        }
        return result;
    }
}
```

```python
class Solution:
    def threeSum(nums:List[int])->List[List[int]]:
        ans=[]
        n=len(nums)
        nums.sort()
        for i in range(n):
            left=i+1
            right=n-1
            if nums[i]>0:
                break
            if i>=1 and nums[i]==nums[i-1]:
                continue
            while left<right:
                total=nums[i]+nums[left]+nums[right]
                if total>0:
                    right-=1
                elif total<0:
                    left+=1
                else:
                    ans.append([nums[i],nums[left],nums[right]])
                    while left!=right and nums[left]==nums[left+1]:left+=1
                    while left!=right and nums[right]==nums[right-1]:right-=1
                    left+=1
                    right-=1
        return ans
```


### (10) 18、四数之和
题目链接：https://leetcode-cn.com/problems/4sum/

```Java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
       
        for (int i = 0; i < nums.length; i++) {

            if (i > 0 && nums[i - 1] == nums[i]) {
                continue;
            }
            
            for (int j = i + 1; j < nums.length; j++) {

                if (j > i + 1 && nums[j - 1] == nums[j]) {
                    continue;
                }

                int left = j + 1;
                int right = nums.length - 1;
                while (right > left) {
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum > target) {
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        left++;
                        right--;
                    }
                }
            }
        }
        return result;
    }
}
```

```python
class Solution:
    def fourSum(nums:List[int],target:int)->List[List[int]]:
        hashmap=dict()
        for n in nums:
            if n in hashmap:
                hashmap[n]+=1
            else:
                hashmap[n]=1

        ans=set()
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                for k in range(j+1,len(nums)):
                    val =target-(nums[i]+nums[j]+nums[k])
                    if val in hashmap:
                        count=(nums[i]==val)+(nums[j]==val)+(nums[k]==val)
                        if hashmap[val]>count:
                            ans.add(tuple(sorted([nums[i],nums[j],nums[k],val])))
                    else:
                        continue
        return ans
```


### 四、字符串的题目 [↑](./README.md)

### （1）344、反转字符串
题目链接：https://leetcode-cn.com/problems/reverse-string/

```Java
class Solution {
    public void reverseString(char[] s) {

       int left = 0;
       int right = s.length-1;
       while(left<right){
           char tmp1 = s[left];
           char tmp2 = s[right];
           s[right] = tmp1;
           s[left] = tmp2;

           left++;
           right--;

       }
    }
}
```
```python
class Solution:
    def reverseString(s:List[str])->None:
        left,right=0,len(s)-1
        while left<right:
            tmp1=s[left]
            tmp2=s[right]
            s[right]=tmp1
            s[left]=tmp2

            left+=1
            right-=1
```


### (2) 541、反转字符串II
题目链接：https://leetcode-cn.com/problems/reverse-string-ii/

```Java
class Solution {
    public String reverseStr(String s, int k) {
     StringBuffer res = new StringBuffer();
     int length = s.length();
     int start = 0;
     while(start<length){
         StringBuffer temp = new StringBuffer();
         //找到k和2k处
         int firstK = (start + k >length)?length:start+k;
         int secondK = (start + (2*k) >length )? length : start+(2*k);

         //start开始的位置，肯定套反转
         temp.append(s.substring(start,firstK));
         res.append(temp.reverse());

         //如果fisrtK 到 secondK 之间有元素，这些元素放入res之间即可
         if(firstK<secondK){
             res.append(s.substring(firstK,secondK));
         }
         start += (2*k);
     }
     return res.toString();
    }
}
```

```python
class Solution:
    def reverseStr(s:str,k:int)->str:

        def reverseString(s1):
            left, right = 0, len(s1) - 1
            while left < right:
                s1[left],s1[right]=s1[right],s1[left]
                left += 1
                right -= 1
            return s1

        t=list(s)
        print(t)
        for i in range(0,len(t),2*k):
            t[i:i+k]=reverseString(t[i:i+k])
        return "".join(t)
```

### (3) 05、替换空格
题目链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/submissions/

```Java
class Solution {
    public String replaceSpace(String s) {
     if(s==null){
         return null;
     }

     StringBuffer sb = new StringBuffer();
     for(int i= 0;i<s.length();i++){
        if(" ".equals(String.valueOf(s.charAt(i)))){
            sb.append("%20");
        }else{
            sb.append(s.charAt(i));
        }

     }
     return sb.toString();
}
}

```

```python
class Solution:
    def replaceSpace(s:str)->str:
        #方法一：
        # t=list(s)
        # for i in range(0,len(t)):
        #     if t[i]==' ':
        #         t[i]="%20"
        # return "".join(t)
        #
        #方法二：
        t=s.split(' ')
        return "%20".join(t)
```


### (4) 151、翻转字符串里的单词
题目链接：https://leetcode-cn.com/problems/reverse-words-in-a-string/submissions/

```Java
class Solution {
   /**
     * 不使用Java内置方法实现
     * <p>
     * 1.去除首尾以及中间多余空格
     * 2.反转整个字符串
     * 3.反转各个单词
     */
    public String reverseWords(String s) {
        // System.out.println("ReverseWords.reverseWords2() called with: s = [" + s + "]");
        // 1.去除首尾以及中间多余空格
        StringBuilder sb = removeSpace(s);
        // 2.反转整个字符串
        reverseString(sb, 0, sb.length() - 1);
        // 3.反转各个单词
        reverseEachWord(sb);
        return sb.toString();
    }

    private StringBuilder removeSpace(String s) {
        // System.out.println("ReverseWords.removeSpace() called with: s = [" + s + "]");
        int start = 0;
        int end = s.length() - 1;
        while (s.charAt(start) == ' ') start++;
        while (s.charAt(end) == ' ') end--;
        StringBuilder sb = new StringBuilder();
        while (start <= end) {
            char c = s.charAt(start);
            if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') {
                sb.append(c);
            }
            start++;
        }
        // System.out.println("ReverseWords.removeSpace returned: sb = [" + sb + "]");
        return sb;
    }

    /**
     * 反转字符串指定区间[start, end]的字符
     */
    public void reverseString(StringBuilder sb, int start, int end) {
        // System.out.println("ReverseWords.reverseString() called with: sb = [" + sb + "], start = [" + start + "], end = [" + end + "]");
        while (start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
        }
        // System.out.println("ReverseWords.reverseString returned: sb = [" + sb + "]");
    }

    private void reverseEachWord(StringBuilder sb) {
        int start = 0;
        int end = 1;
        int n = sb.length();
        while (start < n) {
            while (end < n && sb.charAt(end) != ' ') {
                end++;
            }
            reverseString(sb, start, end - 1);
            start = end + 1;
            end = start + 1;
        }
    }
}
```

```python
class Solution:
    def reverseWords(s:str)->str:
        # return " ".join(reversed(s.split()))  #调用API实现单词翻转
        #使用双端队列
        left,right=0,len(s)-1
        #去掉字符串开头的空白字符
        while left<=right and s[left]==' ':
            left+=1
        #去掉字符串末尾的空白字符
        while left<=right and s[right]==' ':
            right-=1

        d,word= collections.deque(),[]
        #将单词push到队列的头部
        while left<=right:
            print("left=",left)
            print("s[left]=",s[left])
            print("word=",word)
            print("d=",d)
            if s[left]==' 'and word:
                d.appendleft("".join(word))
                word=[]
            elif s[left]!=" ":
                word.append(s[left])
            left+=1
        d.appendleft("".join(word))

        return " ".join(d)
```

### (5) 58、左旋字符串
题目链接：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/submissions/

```Java
class Solution {
    public String reverseLeftWords(String s, int n) {
     int len = s.length();
     StringBuilder sb = new StringBuilder(s);
     //1、反转区间为前n的子串
     reverString(sb,0,n-1);
     //2、反转区间为n到末尾的子串
     reverString(sb,n,len-1);
     //3、反转整个字符串
     return sb.reverse().toString();
    }

    private void reverString(StringBuilder sb,int left,int right){
        while(left<right){
           char temp = sb.charAt(left);
           sb.setCharAt(left,sb.charAt(right));
           sb.setCharAt(right,temp);
           left++;
           right--; 
        }
    }
}
```

```python
class Solution:
    def reversedLeftWords(s:str,n:int):
        #方法一
        # leng= len(s)
        # t=list(s)
        #
        # def reverString(s,left,right):
        #     while left<=right:
        #         s[left],s[right]=s[right],s[left]
        #         left+=1
        #         right-=1
        #     return list("".join(s))
        #
        # #翻转区间为前n的子串
        # r1=reverString(t,0,n-1)
        # #翻转区间为n到末尾的子串
        # r2=reverString(r1,n,leng-1)
        # #翻转整个字符串
        # return "".join(reverString(r2,0,leng-1))

       #方法二：字符串切片
       # return s[n:]+s[:n]

       #方法三：列表遍历
       res=[]
       for i in range(n,len(s)):
           res.append(s[i])
       for i in range(n):
           res.append(s[i])
       return "".join(res)
```

### (6) 28、实现strStr()
题目链接：https://leetcode-cn.com/problems/implement-strstr/submissions/

```Java
class Solution {

    //kmp算法
    //得到前缀表
    public void getNext(int[] next,String s){
       int j =-1;
       next[0]= j;
       for(int i=1;i<s.length();i++){
           while(j>=0 && s.charAt(i)!=s.charAt(j+1)){
               j = next[j];
           }
           if(s.charAt(i)==s.charAt(j+1)){
               j++;
           }
           next[i] = j;
       }
    }
    public int strStr(String haystack, String needle) {
     if(needle.length()==0){
       return 0;
     }

     int[] next = new int[needle.length()];
     getNext(next,needle);
     int j = -1;
     for(int i=0;i<haystack.length();i++){
         while(j>=0 && haystack.charAt(i)!=needle.charAt(j+1)){
             j = next[j];
         }
         if(haystack.charAt(i)==needle.charAt(j+1)){
             j++;
         }
         if(j==needle.length()-1){
             return (i-needle.length()+1);
         }
     }
     return -1;
    }
}
```

```python
class Solution:
    #KMP算法
    def strStr(self, haystack: str, needle: str) -> int:
        a=len(needle)
        b=len(haystack)
        if a==0:
            return 0
        next=self.getnext(a,needle)
        p=-1
        for j in range(b):
            while p>=0 and needle[p+1]!=haystack[j]:
                p=next[p]
            if needle[p+1]==haystack[j]:
                p+=1
            if p==a-1:
                return j-a+1
        return -1

    def getnext(self,a,needle):
        next=['' for i in range(a)]
        k=-1
        next[0]=k
        for i in range(1,len(needle)):
            while (k>-1 and needle[k+1]!=needle[i]):
                k=next[k]
            if needle[k+1]==needle[i]:
                k+=1
            next[i]=k
        return next
```



### (6) 459、重复的字符串
题目链接：https://leetcode-cn.com/problems/repeated-substring-pattern/

```Java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
      if(s.equals("")) return false;

      int len = s.length();
      s = " "+s;
      char[] c = s.toCharArray();
      int[] next = new int[len+1];

      for(int i=2,j=0;i<=len;i++){
          while(j>0 && c[i]!=c[j+1]){
              j = next[j];
          }
          if(c[i]==c[j+1]){
              j++;
          }
          next[i] = j;
      }

      if(next[len]>0 && len%(len-next[len])==0){
          return true;
      } 
      return false;   
   }
}
```

```python
class Solution:
    def repeatedSubstringPattern(self,s:str)->bool:
        n=len(s)
        for i in range(1,n//2+1):
            if n%i==0:
                if all(s[j]==s[j-i] for j in range(i,n)):
                    return True
        return False
```


### 五、双指针法的题目

### (1) 27、移除元素
题目链接：https://leetcode-cn.com/problems/remove-element/
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i,n = 0,len(nums)
        for j in range(n):
            if nums[j] != val:
                nums[i] = nums[j]
                i += 1
        return i
```

### (2) 344、反转字符串
题目链接：https://leetcode-cn.com/problems/reverse-string/
```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while(left < right):
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```
### (3) 剑指05、替换空格
题目链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/
```c++
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0; // 统计空格的个数
        int sOldSize = s.size();
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == ' ') {
                count++;
            }
        }
        // 扩充字符串s的大小，也就是每个空格替换成"%20"之后的大小
        s.resize(s.size() + count * 2);
        int sNewSize = s.size();
        // 从后先前将空格替换为"%20"
        for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {
            if (s[j] != ' ') {
                s[i] = s[j];
            } else {
                s[i] = '0';
                s[i - 1] = '2';
                s[i - 2] = '%';
                i -= 2;
            }
        }
        return s;
    }
};
```

### (4) 151、翻转字符串里的单词
题目链接：https://leetcode-cn.com/problems/reverse-words-in-a-string/
```c++
// 版本一
class Solution {
public:
    // 反转字符串s中左闭又闭的区间[start, end]
    void reverse(string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }

    // 移除冗余空格：使用双指针（快慢指针法）O(n)的算法
    void removeExtraSpaces(string& s) {
        int slowIndex = 0, fastIndex = 0; // 定义快指针，慢指针
        // 去掉字符串前面的空格
        while (s.size() > 0 && fastIndex < s.size() && s[fastIndex] == ' ') {
            fastIndex++;
        }
        for (; fastIndex < s.size(); fastIndex++) {
            // 去掉字符串中间部分的冗余空格
            if (fastIndex - 1 > 0
                    && s[fastIndex - 1] == s[fastIndex]
                    && s[fastIndex] == ' ') {
                continue;
            } else {
                s[slowIndex++] = s[fastIndex];
            }
        }
        if (slowIndex - 1 > 0 && s[slowIndex - 1] == ' ') { // 去掉字符串末尾的空格
            s.resize(slowIndex - 1);
        } else {
            s.resize(slowIndex); // 重新设置字符串大小
        }
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); // 去掉冗余空格
        reverse(s, 0, s.size() - 1); // 将字符串全部反转
        int start = 0; // 反转的单词在字符串里起始位置
        int end = 0; // 反转的单词在字符串里终止位置
        bool entry = false; // 标记枚举字符串的过程中是否已经进入了单词区间
        for (int i = 0; i < s.size(); i++) { // 开始反转单词
            if ((!entry))) {
                start = i; // 确定单词起始位置
                entry = true; // 进入单词区间
            }
            // 单词后面有空格的情况，空格就是分词符
            if (entry && s[i] == ' ' && s[i - 1] != ' ') {
                end = i - 1; // 确定单词终止位置
                entry = false; // 结束单词区间
                reverse(s, start, end);
            }
            // 最后一个结尾单词之后没有空格的情况
            if (entry && (i == (s.size() - 1)) && s[i] != ' ' ) {
                end = i;// 确定单词终止位置
                entry = false; // 结束单词区间
                reverse(s, start, end);
            }
        }
        return s;
    }
    
    /* 主函数简单写法
    string reverseWords(string s) {
        removeExtraSpaces(s);
        reverse(s, 0, s.size() - 1);
        for(int i = 0; i < s.size(); i++) {
            int j = i;
            // 查找单词间的空格，翻转单词
            while(j < s.size() && s[j] != ' ') j++;
            reverse(s, i, j - 1);
            i = j;
        }
        return s;
    }
    */
};
```

### (5) 206、翻转链表
题目链接：https://leetcode-cn.com/problems/reverse-linked-list/
```python
#双指针
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        cur = head   
        pre = None
        while(cur!=None):
            temp = cur.next # 保存一下 cur的下一个节点，因为接下来要改变cur->next
            cur.next = pre #反转
            #更新pre、cur指针
            pre = cur
            cur = temp
        return pre
```
 
### (6) 19、删除链表的倒数第N个节点
题目链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        head_dummy = ListNode()
        head_dummy.next = head

        slow, fast = head_dummy, head_dummy
        while(n!=0): #fast先往前走n步
            fast = fast.next
            n -= 1
        while(fast.next!=None):
            slow = slow.next
            fast = fast.next
        #fast 走到结尾后，slow的下一个节点为倒数第N个节点
        slow.next = slow.next.next #删除
        return head_dummy.next
```

### （7）0207、链表相交
题目链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        lengthA,lengthB = 0,0
        curA,curB = headA,headB
        while(curA!=None): #求链表A的长度
            curA = curA.next
            lengthA +=1
        
        while(curB!=None): #求链表B的长度
            curB = curB.next
            lengthB +=1
        
        curA, curB = headA, headB

        if lengthB>lengthA: #让curA为最长链表的头，lenA为其长度
            lengthA, lengthB = lengthB, lengthA
            curA, curB = curB, curA

        gap = lengthA - lengthB #求长度差
        while(gap!=0): 
            curA = curA.next #让curA和curB在同一起点上
            gap -= 1
        
        while(curA!=None):
            if curA == curB:
                return curA
            else:
                curA = curA.next
                curB = curB.next
        return None
```

### (8) 142、环形链表II
题目链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/
```python
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            # 如果相遇
            if slow == fast:
                p = head
                q = slow
                while p!=q:
                    p = p.next
                    q = q.next
                #你也可以return q
                return p

        return None
 ```       
    
### (9) 15、三数之和
题目链接：https://leetcode-cn.com/problems/3sum/
```python
class Solution:
    def threeSum(self, nums):
        ans = []
        n = len(nums)
        nums.sort()
        for i in range(n):
            left = i + 1
            right = n - 1
            if nums[i] > 0:
                break
            if i >= 1 and nums[i] == nums[i - 1]:
                continue
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total > 0:
                    right -= 1
                elif total < 0:
                    left += 1
                else:
                    ans.append([nums[i], nums[left], nums[right]])
                    while left != right and nums[left] == nums[left + 1]: left += 1
                    while left != right and nums[right] == nums[right - 1]: right -= 1
                    left += 1
                    right -= 1
        return ans
 ```
 ### (10) 18、四数之和
 题目链接：https://leetcode-cn.com/problems/4sum/
 ```python
 class Solution(object):
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        # use a dict to store value:showtimes
        hashmap = dict()
        for n in nums:
            if n in hashmap:
                hashmap[n] += 1
            else: 
                hashmap[n] = 1
        
        # good thing about using python is you can use set to drop duplicates.
        ans = set()
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    val = target - (nums[i] + nums[j] + nums[k])
                    if val in hashmap:
                        # make sure no duplicates.
                        count = (nums[i] == val) + (nums[j] == val) + (nums[k] == val)
                        if hashmap[val] > count:
                            ans.add(tuple(sorted([nums[i], nums[j], nums[k], val])))
                    else:
                        continue
        return ans
  ```
  
### 六、栈与队列 [↑](./README.md)

### （1）232、用栈实现队列
题目链接：https://leetcode-cn.com/problems/implement-queue-using-stacks/
```python
# 使用两个栈实现先进先出的队列
class MyQueue:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack1 = list()
        self.stack2 = list()

    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        # self.stack1用于接受元素
        self.stack1.append(x)

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        # self.stack2用于弹出元素，如果self.stack2为[],则将self.stack1中元素全部弹出给self.stack2
        if self.stack2 == []:
            while self.stack1:
                tmp = self.stack1.pop()
                self.stack2.append(tmp)
        return self.stack2.pop()

    def peek(self) -> int:
        """
        Get the front element.
        """
        if self.stack2 == []:
            while self.stack1:
                tmp = self.stack1.pop()
                self.stack2.append(tmp)
        return self.stack2[-1]

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return self.stack1 == [] and self.stack2 == []
 ```
 
 ### (2) 225、用队列实现栈
 题目链接：https://leetcode-cn.com/problems/implement-stack-using-queues/
 
 ```python
 from collections import deque
class MyStack:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        #使用两个队列来实现
        self.que1 = deque()
        self.que2 = deque()

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.que1.append(x)

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        size = len(self.que1)
        size -= 1#这里先减一是为了保证最后面的元素
        while size > 0:
            size -= 1
            self.que2.append(self.que1.popleft())


        result = self.que1.popleft()
        self.que1, self.que2= self.que2, self.que1#将que2和que1交换 que1经过之前的操作应该是空了
        #一定注意不能直接使用que1 = que2 这样que2的改变会影响que1 可以用浅拷贝
        return result

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.que1[-1]

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        #print(self.que1)
        if len(self.que1) == 0:
            return True
        else:
            return False


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
```

### (3) 20、有效的括号
题目链接：https://leetcode-cn.com/problems/valid-parentheses/
```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []  # 保存还未匹配的左括号
        mapping = {")": "(", "]": "[", "}": "{"}
        for i in s:
            if i in "([{":  # 当前是左括号，则入栈
                stack.append(i)
            elif stack and stack[-1] == mapping[i]:  # 当前是配对的右括号则出栈
                stack.pop()
            else:  # 不是匹配的右括号或者没有左括号与之匹配，则返回false
                return False
        return stack == []  # 最后必须正好把左括号匹配完
```

### (4) 1047、删除字符串中的所有相邻重复项
题目链接：https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/
```python
class Solution:
    def removeDuplicates(self, s: str) -> str:
        t = list()
        for i in s:
            if t and t[-1] == i:
                t.pop(-1)
            else:
                t.append(i)
        return "".join(t)  # 字符串拼接
```

### (5) 150、逆波兰表达式求值
题目链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/
```python
def evalRPN(tokens) -> int:
    stack = list()
    for i in range(len(tokens)):
        if tokens[i] not in ["+", "-", "*", "/"]:
            stack.append(tokens[i])
        else:
            tmp1 = stack.pop()
            tmp2 = stack.pop()
            res = eval(tmp2+tokens[i]+tmp1)
            stack.append(str(int(res)))
    return stack[-1]
```
 
### (6) 239、滑动窗口最大值
题目链接：https://leetcode-cn.com/problems/sliding-window-maximum/
```python
 class MyQueue: #单调队列（从大到小
    def __init__(self):
        self.queue = [] #使用list来实现单调队列
    
    #每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
    #同时pop之前判断队列当前是否为空。
    def pop(self, value):
        if self.queue and value == self.queue[0]:
            self.queue.pop(0)#list.pop()时间复杂度为O(n),这里可以使用collections.deque()
            
    #如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
    #这样就保持了队列里的数值是单调从大到小的了。
    def push(self, value):
        while self.queue and value > self.queue[-1]:
            self.queue.pop()
        self.queue.append(value)
        
    #查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
    def front(self):
        return self.queue[0]
    
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        que = MyQueue()
        result = []
        for i in range(k): #先将前k的元素放进队列
            que.push(nums[i])
        result.append(que.front()) #result 记录前k的元素的最大值
        for i in range(k, len(nums)):
            que.pop(nums[i - k]) #滑动窗口移除最前面元素
            que.push(nums[i]) #滑动窗口前加入最后面的元素
            result.append(que.front()) #记录对应的最大值
        return result
```

### (7) 347、前K个高频元素
题目链接：https://leetcode-cn.com/problems/top-k-frequent-elements/
```python
#时间复杂度：O(nlogk)
#空间复杂度：O(n)
import heapq
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #要统计元素出现频率
        map_ = {} #nums[i]:对应出现的次数
        for i in range(len(nums)):
            map_[nums[i]] = map_.get(nums[i], 0) + 1
        
        #对频率排序
        #定义一个小顶堆，大小为k
        pri_que = [] #小顶堆
        
        #用固定大小为k的小顶堆，扫面所有频率的数值
        for key, freq in map_.items():
            heapq.heappush(pri_que, (freq, key))
            if len(pri_que) > k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                heapq.heappop(pri_que)
        
        #找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组
        result = [0] * k
        for i in range(k-1, -1, -1):
            result[i] = heapq.heappop(pri_que)[1]
        return result
```

### 七、二叉树的题目 [↑](./README.md)

### 1、 二叉树的遍历方式 [↑](./README.md)

### （1）144、二叉树的前序遍历
题目链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st= []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #右
                    st.append(node.right)
                if node.left: #左
                    st.append(node.left)
                st.append(node) #中
                st.append(None)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```        

### （2）145、二叉树的后序遍历
题目链接：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/
```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                st.append(node) #中
                st.append(None)
                
                if node.right: #右
                    st.append(node.right)
                if node.left: #左
                    st.append(node.left)
            else:
                node = st.pop()
                result.append(node.val)
        return result
```


### （3）94、二叉树的中序遍历
题目链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []
        st = []
        if root:
            st.append(root)
        while st:
            node = st.pop()
            if node != None:
                if node.right: #添加右节点（空节点不入栈）
                    st.append(node.right)
                
                st.append(node) #添加中节点
                st.append(None) #中节点访问过，但是还没有处理，加入空节点做为标记。
                
                if node.left: #添加左节点（空节点不入栈）
                    st.append(node.left)
            else: #只有遇到空节点的时候，才将下一个节点放进结果集
                node = st.pop() #重新取出栈中元素
                result.append(node.val) #加入到结果集
        return result
 ```

### （4）102、二叉树的层序遍历
题目链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []

        quene = [root]
        out_list = []

        while quene:
            length = len(queue)  # 这里一定要先求出队列的长度，不能用range(len(queue))，因为queue长度是变化的
            in_list = []
            for _ in range(length):
                curnode = queue.pop(0)  # （默认移除列表最后一个元素）这里需要移除队列最头上的那个
                in_list.append(curnode.val)
                if curnode.left: queue.append(curnode.left)
                if curnode.right: queue.append(curnode.right)
            out_list.append(in_list)

        return out_list
```

### （5）107、二叉树的层序遍历II
题目链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        quene = [root]
        out_list = []
        
        while quene:
            in_list = []
            for _ in range(len(quene)):
                node = quene.pop(0)
                in_list.append(node.val)
                if node.left:
                    quene.append(node.left)
                if node.right:
                    quene.append(node.right)
 
            out_list.append(in_list)
    
        out_list.reverse()
        return out_list
```

### (6) 199、二叉树的右视图
题目链接：https://leetcode-cn.com/problems/binary-tree-right-side-view/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        # deque来自collections模块，不在力扣平台时，需要手动写入
        # 'from collections import deque' 导入
        # deque相比list的好处是，list的pop(0)是O(n)复杂度，deque的popleft()是O(1)复杂度

        quene = deque([root])
        out_list = []

        while quene:
            # 每次都取最后一个node就可以了
            node = quene[-1]
            out_list.append(node.val)

            # 执行这个遍历的目的是获取下一层所有的node
            for _ in range(len(quene)):
                node = quene.popleft()
                if node.left:
                    quene.append(node.left)
                if node.right:
                    quene.append(node.right)
        
        return out_list
```

### (7) 637、二叉树的层平均值
题目链接：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def averageOfLevels(self, root: TreeNode) -> List[float]:
        if not root:
            return []
        
        quene = deque([root])
        out_list = []

        while quene:
            in_list = []

            for _ in range(len(quene)):
                node = quene.popleft()
                in_list.append(node.val)
                if node.left:
                    quene.append(node.left)
                if node.right:
                    quene.append(node.right)

            out_list.append(in_list)

        out_list = map(lambda x: sum(x) / len(x), out_list)
    
        return out_list
```

### (8) 429、N叉树的层序遍历
题目链接：https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/
```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return []
        
        quene = deque([root])
        out_list = []

        while quene:
            in_list = []

            for _ in range(len(quene)):
                node = quene.popleft()
                in_list.append(node.val)
                if node.children:
                    # 这个地方要用extend而不是append，我们看下面的例子：
                    # In [18]: alist=[]
                    # In [19]: alist.append([1,2,3])
                    # In [20]: alist
                    # Out[20]: [[1, 2, 3]]
                    # In [21]: alist.extend([4,5,6])
                    # In [22]: alist
                    # Out[22]: [[1, 2, 3], 4, 5, 6]
                    # 可以看到extend对要添加的list进行了一个解包操作
                    # print(root.children)，可以得到children是一个包含
                    # 孩子节点地址的list，我们使用for遍历quene的时候，
                    # 希望quene是一个单层list，所以要用extend
                    # 使用extend的情况，如果print(quene),结果是
                    # deque([<__main__.Node object at 0x7f60763ae0a0>])
				   # deque([<__main__.Node object at 0x7f607636e6d0>, <__main__.Node object at 0x7f607636e130>, <__main__.Node object at 0x7f607636e310>])
				  # deque([<__main__.Node object at 0x7f607636e880>, <__main__.Node object at 0x7f607636ef10>])
				  # 可以看到是单层list
                    # 如果使用append，print(quene)的结果是
                    # deque([<__main__.Node object at 0x7f18907530a0>])
				  # deque([[<__main__.Node object at 0x7f18907136d0>, <__main__.Node object at 0x7f1890713130>, <__main__.Node object at 0x7f1890713310>]])
				  # 可以看到是两层list，这样for的遍历就会报错
                    
                    quene.extend(node.children)
                
            out_list.append(in_list)
        
        return out_list
```

### (9) 515、在每个树行中找最大值
题目链接：https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/

```c++
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<int> result;
        while (!que.empty()) {
            int size = que.size();
            int maxValue = INT_MIN; // 取每一层的最大值
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                maxValue = node->val > maxValue ? node->val : maxValue;
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(maxValue); // 把最大值放进数组
        }
        return result;
    }
};
```
### (10) 116、填充每个节点的下一个右侧节点指针
题目链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/

```python
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    nodePre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = nodePre;
                } else {
                    node = que.front();
                    que.pop();
                    nodePre->next = node; // 本层前一个节点next指向本节点
                    nodePre = nodePre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;

    }
};
```

### （11）117、填充每个节点的下一个右侧节点指针II
题目链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/

```C++
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    nodePre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = nodePre;
                } else {
                    node = que.front();
                    que.pop();
                    nodePre->next = node; // 本层前一个节点next指向本节点
                    nodePre = nodePre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;
    }
};
```
### 2、 求二叉树的属性 [↑](./README.md)

### (12) 226、翻转二叉树
题目链接：https://leetcode-cn.com/problems/invert-binary-tree/

```python
#递归法：前序遍历

class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left #中
        self.invertTree(root.left) #左
        self.invertTree(root.right) #右
        return root
#迭代法：深度优先遍历（前序遍历）

class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        st = []
        st.append(root)
        while st:
            node = st.pop()
            node.left, node.right = node.right, node.left #中
            if node.right:
                st.append(node.right) #右
            if node.left:
                st.append(node.left) #左
        return root
#迭代法：广度优先遍历（层序遍历）

import collections
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        queue = collections.deque() #使用deque()
        if root:
            queue.append(root)
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                node.left, node.right = node.right, node.left #节点处理
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return root
```

### (13) 101、对称二叉树
题目链接：https://leetcode-cn.com/problems/symmetric-tree/
```python

#递归法

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        return self.compare(root.left, root.right)
        
    def compare(self, left, right):
        #首先排除空节点的情况
        if left == None and right != None: return False
        elif left != None and right == None: return False
        elif left == None and right == None: return True
        #排除了空节点，再排除数值不相同的情况
        elif left.val != right.val: return False
        
        #此时就是：左右节点都不为空，且数值相同的情况
        #此时才做递归，做下一层的判断
        outside = self.compare(left.left, right.right) #左子树：左、 右子树：右
        inside = self.compare(left.right, right.left) #左子树：右、 右子树：左
        isSame = outside and inside #左子树：中、 右子树：中 （逻辑处理）
        return isSame
#迭代法： 使用队列

import collections
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        queue = collections.deque()
        queue.append(root.left) #将左子树头结点加入队列
        queue.append(root.right) #将右子树头结点加入队列
        while queue: #接下来就要判断这这两个树是否相互翻转
            leftNode = queue.popleft()
            rightNode = queue.popleft()
            if not leftNode and not rightNode: #左节点为空、右节点为空，此时说明是对称的
                continue
            
            #左右一个节点不为空，或者都不为空但数值不相同，返回false
            if not leftNode or not rightNode or leftNode.val != rightNode.val:
                return False
            queue.append(leftNode.left) #加入左节点左孩子
            queue.append(rightNode.right) #加入右节点右孩子
            queue.append(leftNode.right) #加入左节点右孩子
            queue.append(rightNode.left) #加入右节点左孩子
        return True
#迭代法：使用栈

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        st = [] #这里改成了栈
        st.append(root.left)
        st.append(root.right)
        while st:
            leftNode = st.pop()
            rightNode = st.pop()
            if not leftNode and not rightNode:
                continue
            if not leftNode or not rightNode or leftNode.val != rightNode.val:
                return False
            st.append(leftNode.left)
            st.append(rightNode.right)
            st.append(leftNode.right)
            st.append(rightNode.left)
        return True
```

### (14) 104、二叉树的最大深度
题目链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

```python
#递归法：

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        return self.getDepth(root)
        
    def getDepth(self, node):
        if not node:
            return 0
        leftDepth = self.getDepth(node.left) #左
        rightDepth = self.getDepth(node.right) #右
        depth = 1 + max(leftDepth, rightDepth) #中
        return depth
#递归法；精简代码

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
#迭代法：

import collections
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        depth = 0 #记录深度
        queue = collections.deque()
        queue.append(root)
        while queue:
            size = len(queue)
            depth += 1
            for i in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return depth
        
```

### (15）559、N叉树的最大深度
题目链接：https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/

```python
#递归法：

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        depth = 0
        for i in range(len(root.children)):
            depth = max(depth, self.maxDepth(root.children[i]))
        return depth + 1
#迭代法：

import collections
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        queue = collections.deque()
        if root:
            queue.append(root)
        depth = 0 #记录深度
        while queue:
            size = len(queue)
            depth += 1
            for i in range(size):
                node = queue.popleft()
                for j in range(len(node.children)):
                    if node.children[j]:
                        queue.append(node.children[j])
        return depth
#使用栈来模拟后序遍历依然可以

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        st = []
        if root:
            st.append(root)
        depth = 0
        result = 0
        while st:
            node = st.pop()
            if node != None:
                st.append(node) #中
                st.append(None)
                depth += 1
                for i in range(len(node.children)): #处理孩子
                    if node.children[i]:
                        st.append(node.children[i])
                    
            else:
                node = st.pop()
                depth -= 1
            result = max(result, depth)
        return result
```

### (16) 111、二叉树的最小深度
题目链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/

```python
#递归法：

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1

        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth) # 获得左子树的最小高度
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth) # 获得右子树的最小高度
        return min_depth + 1
#迭代法：

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        que = deque()
        que.append(root)
        res = 1

        while que:
            for _ in range(len(que)):
                node = que.popleft()
                # 当左右孩子都为空的时候，说明是最低点的一层了，退出
                if not node.left and not node.right:
                    return res
                if node.left is not None:
                    que.append(node.left)
                if node.right is not None:
                    que.append(node.right)
            res += 1
        return res
```
### (17) 222、完全二叉树的节点个数
题目链接：https://leetcode-cn.com/problems/count-complete-tree-nodes/

```python
#递归法：

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        return self.getNodesNum(root)
        
    def getNodesNum(self, cur):
        if not cur:
            return 0
        leftNum = self.getNodesNum(cur.left) #左
        rightNum = self.getNodesNum(cur.right) #右
        treeNum = leftNum + rightNum + 1 #中
        return treeNum
#递归法：精简版

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
#迭代法：

import collections
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        queue = collections.deque()
        if root:
            queue.append(root)
        result = 0
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                result += 1 #记录节点数量
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return result
#完全二叉树

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        left = root.left
        right = root.right
        leftHeight = 0 #这里初始为0是有目的的，为了下面求指数方便
        rightHeight = 0
        while left: #求左子树深度
            left = left.left
            leftHeight += 1
        while right: #求右子树深度
            right = right.right
            rightHeight += 1
        if leftHeight == rightHeight:
            return (2 << leftHeight) - 1 #注意(2<<1) 相当于2^2，所以leftHeight初始为0
        return self.countNodes(root.left) + self.countNodes(root.right) + 1
```

### (18) 110、平衡二叉树
题目链接：https://leetcode-cn.com/problems/balanced-binary-tree/

```python
#递归法：

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        return True if self.getDepth(root) != -1 else False
    
    #返回以该节点为根节点的二叉树的高度，如果不是二叉搜索树了则返回-1
    def getDepth(self, node):
        if not node:
            return 0
        leftDepth = self.getDepth(node.left)
        if leftDepth == -1: return -1 #说明左子树已经不是二叉平衡树
        rightDepth = self.getDepth(node.right)
        if rightDepth == -1: return -1 #说明右子树已经不是二叉平衡树
        return -1 if abs(leftDepth - rightDepth)>1 else 1 + max(leftDepth, rightDepth)
#迭代法：

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        st = []
        if not root:
            return True
        st.append(root)
        while st:
            node = st.pop() #中
            if abs(self.getDepth(node.left) - self.getDepth(node.right)) > 1:
                return False
            if node.right:
                st.append(node.right) #右（空节点不入栈）
            if node.left:
                st.append(node.left) #左（空节点不入栈）
        return True
    
    def getDepth(self, cur):
        st = []
        if cur:
            st.append(cur)
        depth = 0
        result = 0
        while st:
            node = st.pop()
            if node:
                st.append(node) #中
                st.append(None)
                depth += 1
                if node.right: st.append(node.right) #右
                if node.left: st.append(node.left) #左
            else:
                node = st.pop()
                depth -= 1
            result = max(result, depth)
        return result
```

### (19) 257、二叉树的所有路径
题目链接：https://leetcode-cn.com/problems/binary-tree-paths/
```python
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        path=[]
        res=[]
        def backtrace(root, path):
            if not root:return 
            path.append(root.val)
            if (not root.left)and (not root.right):
               res.append(path[:])
            ways=[]
            if root.left:ways.append(root.left)
            if root.right:ways.append(root.right)
            for way in ways:
                backtrace(way,path)
                path.pop()
        backtrace(root,path)
        return ["->".join(list(map(str,i))) for i in res]
	
#回溯法
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        result = []
        path = []
        if not root:
            return result
        self.traversal(root, path, result)
        return result
        
    def traversal(self, cur, path, result):
        path.append(cur.val)
        #这才到了叶子节点
        if not cur.left and not cur.right:
            sPath = ""
            for i in range(len(path)-1):
                sPath += str(path[i])
                sPath += "->"
            sPath += str(path[len(path)-1])
            result.append(sPath)
            return
        if cur.left:
            self.traversal(cur.left, path, result)
            path.pop() #回溯
        if cur.right:
            self.traversal(cur.right, path, result)
            path.pop() #回溯

  ```
  
### (20) 404、左叶子之和
题目链接：https://leetcode-cn.com/problems/sum-of-left-leaves/
```python
  **递归**
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        self.res=0
        def areleftleaves(root):
            if not root:return
            if root.left and (not root.left.left) and (not root.left.right):self.res+=root.left.val
            areleftleaves(root.left)
            areleftleaves(root.right)
        areleftleaves(root)
        return self.res
```

### (21) 513、找树左下角的值
题目链接：https://leetcode-cn.com/problems/find-bottom-left-tree-value/
```python
//递归法
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        depth=0
        self.res=[]
        def level(root,depth):
            if not root:return
            if depth==len(self.res):
                self.res.append([])
                self.res[depth].append(root.val)
            level(root.left,depth+1)
            level(root.right,depth+1)
        level(root,depth)
        return self.res[-1][0]
```

### (22) 112、路径总和
题目链接：https://leetcode-cn.com/problems/path-sum/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

// 递归法

class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        def isornot(root,targetSum)->bool:
            if (not root.left) and (not root.right) and targetSum == 0:return True // 遇到叶子节点，并且计数为0
            if (not root.left) and (not root.right):return False //遇到叶子节点，计数不为0
            if root.left:
                targetSum -= root.left.val  //左节点
                if isornot(root.left,targetSum):return True  //递归，处理左节点
                targetSum += root.left.val  //回溯
            if root.right:
                targetSum -= root.right.val //右节点
                if isornot(root.right,targetSum):return True //递归，处理右节点
                targetSum += root.right.val //回溯
            return False
            
        if root == None:return False  //别忘记处理空TreeNode
        else:return isornot(root,targetSum-root.val)
```

### (23) 113、路径总和II
题目链接：https://leetcode-cn.com/problems/path-sum-ii/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
//递归法
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        path=[]
        res=[]
        def pathes(root,targetSum):
            if (not root.left) and (not root.right) and targetSum == 0: // 遇到叶子节点，并且计数为0
                res.append(path[:])  //找到一种路径，记录到res中，注意必须是path[:]而不是path
                return 
            if (not root.left) and (not root.right):return // 遇到叶子节点直接返回
            if root.left:   //左
                targetSum -= root.left.val
                path.append(root.left.val)     //递归前记录节点
                pathes(root.left,targetSum)    //递归
                targetSum += root.left.val     //回溯
                path.pop()                     //回溯
            if root.right:  //右
                targetSum -= root.right.val
                path.append(root.right.val)    //递归前记录节点
                pathes(root.right,targetSum)   //递归
                targetSum += root.right.val    //回溯
                path.pop()                     //回溯
            return
            
        if root == None:return []             //处理空TreeNode
        else:
            path.append(root.val)             //首先处理根节点
            pathes(root,targetSum-root.val)
            return res
```

### 3、 二叉树的修改与构造 [↑](./README.md)

### (24) 106、从中序与后序遍历序列构造二叉树
题目链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
//递归法
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
            if not postorder: return None  //特殊情况
            root = TreeNode(postorder[-1]) //新建父节点
            p=inorder.index(postorder[-1]) //找到父节点在中序遍历的位置*因为没有重复的元素，才可以这样找
            root.left = self.buildTree(inorder[:p],postorder[:p]) //分割中序数组和后续数组
            root.right = self.buildTree(inorder[p+1:],postorder[p:-1]) //注意右节点时分割中序数组和后续数组的开闭环
            return root
```

### (25) 105、从前序与中序遍历序列构造二叉树
题目链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
//递归法
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
            if not preorder: return None  //特殊情况
            root = TreeNode(preorder[0])  //新建父节点
            p=inorder.index(preorder[0])  //找到父节点在中序遍历的位置(因为没有重复的元素，才可以这样找)
            root.left = self.buildTree(preorder[1:p+1],inorder[:p])  //注意左节点时分割中序数组和前续数组的开闭环
            root.right = self.buildTree(preorder[p+1:],inorder[p+1:])  //分割中序数组和前续数组
            return root
```

### (26) 654、最大二叉树
题目链接：https://leetcode-cn.com/problems/maximum-binary-tree/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
//递归法
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if not nums: return None   //终止条件
        root = TreeNode(max(nums))   //新建节点
        p = nums.index(root.val)   //找到最大值位置
        if p > 0: //保证有左子树
            root.left = self.constructMaximumBinaryTree(nums[:p])   //递归
        if p < len(nums): //保证有右子树
            root.right = self.constructMaximumBinaryTree(nums[p+1:])  //递归
        return root
	
```

### (27) 617、合并二叉树
题目链接：https://leetcode-cn.com/problems/merge-two-binary-trees/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
//递归法*前序遍历
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1: return root2  // 如果t1为空，合并之后就应该是t2
        if not root2: return root1  // 如果t2为空，合并之后就应该是t1
        root1.val = root1.val + root2.val  //中
        root1.left = self.mergeTrees(root1.left , root2.left)  //左
        root1.right = self.mergeTrees(root1.right , root2.right)  //右
        return root1  //root1修改了结构和数值
```

### 4、 求二叉搜索树的属性 [↑](./README.md)

### (28) 700、二叉搜索树中的搜索
题目链接:https://leetcode-cn.com/problems/search-in-a-binary-search-tree/
```python

#递归法：

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root or root.val == val: return root  //为空或者已经找到都是直接返回root，所以合并了
        if root.val > val: return self.searchBST(root.left,val)  //注意一定要加return
        else: return self.searchBST(root.right,val)  
#迭代法：

class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        while root is not None:
            if val < root.val: root = root.left
            elif val > root.val: root = root.right
            else: return root
        return root

```

### (29) 98、验证二叉搜索树
题目链接：https://leetcode-cn.com/problems/validate-binary-search-tree/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
//递归法
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        res = []  //把二叉搜索树按中序遍历写成list
        def buildalist(root):
            if not root: return  
            buildalist(root.left)  //左
            res.append(root.val)  //中
            buildalist(root.right)  //右
            return res  
        buildalist(root)
        return res == sorted(res) and len(set(res)) == len(res) //检查list里的数有没有重复元素，以及是否按从小到大排列
```

### (30) 530、二叉搜索树的最小绝对差
题目链接：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/
```python

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        res = []   
        r = float("inf")
        def buildaList(root):  //把二叉搜索树转换成有序数组
            if not root: return None
            if root.left: buildaList(root.left)  //左
            res.append(root.val)  //中
            if root.right: buildaList(root.right)  //右
            return res
            
        buildaList(root)
        for i in range(len(res)-1):  // 统计有序数组的最小差值
            r = min(abs(res[i]-res[i+1]),r)
        return r
	
```

### (31) 501、二叉树搜索树中的众数
题目链接：https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
//递归法
class Solution:
    def findMode(self, root: TreeNode) -> List[int]:
        if not root: return
        self.pre = root
        self.count = 0   //统计频率
        self.countMax = 0  //最大频率
        self.res = []
        def findNumber(root):
            if not root: return None  // 第一个节点
            findNumber(root.left)  //左
            if self.pre.val == root.val:  //中: 与前一个节点数值相同
                self.count += 1
            else:  // 与前一个节点数值不同
                self.pre = root
                self.count = 1
            if self.count > self.countMax:  // 如果计数大于最大值频率
                self.countMax = self.count  // 更新最大频率
                self.res = [root.val]  //更新res
            elif self.count == self.countMax:  // 如果和最大值相同，放进res中
                self.res.append(root.val)
            findNumber(root.right)  //右
            return
        findNumber(root)
        return self.res
```

### 5、 二叉树的公共祖先问题 [↑](./README.md)

### (32) 236、二叉树的最近公共祖先
题目链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/
```python
 Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
//递归
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q: return root  //找到了节点p或者q，或者遇到空节点
        left = self.lowestCommonAncestor(root.left,p,q)  //左
        right = self.lowestCommonAncestor(root.right,p,q)  //右
        if left and right: return root  //中: left和right不为空，root就是最近公共节点
        elif left and not right: return left  //目标节点是通过left返回的
        elif not left and right: return right  //目标节点是通过right返回的
        else: return None  //没找到
```

### (33) 235、二叉搜索树的最近公共祖先
题目链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root: return root  //中
        if root.val >p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left,p,q)  //左
        elif root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right,p,q)  //右
        else: return root
```

### 6、 二叉搜索树的修改与构造 [↑](./README.md)

### (34) 701、二叉搜索树中的插入操作
题目链接：https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/
```python
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if root is None:
            return TreeNode(val) # 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。
        if root.val < val:
            root.right = self.insertIntoBST(root.right, val) # 递归创建右子树
        if root.val > val:
            root.left = self.insertIntoBST(root.left, val) # 递归创建左子树
        return root
```

### (35) 450、删除二叉搜索树中的节点
题目链接：https://leetcode-cn.com/problems/delete-node-in-a-bst/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root: return root  #第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if root.val == key:  
            if not root.left and not root.right:  #第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
                del root
                return None
            if not root.left and root.right:  #第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
                tmp = root
                root = root.right
                del tmp
                return root
            if root.left and not root.right:  #第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
                tmp = root
                root = root.left
                del tmp
                return root
            else:  #第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
                v = root.right
                while v.left:
                    v = v.left
                v.left = root.left
                tmp = root
                root = root.right
                del tmp
                return root
        if root.val > key: root.left = self.deleteNode(root.left,key)  #左递归
        if root.val < key: root.right = self.deleteNode(root.right,key)  #右递归
        return root
```

### (36) 669、修剪二叉搜索树
题目链接：https://leetcode-cn.com/problems/trim-a-binary-search-tree/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
        if not root: return root
        if root.val < low: 
            return self.trimBST(root.right,low,high)  // 寻找符合区间[low, high]的节点
        if root.val > high:
            return self.trimBST(root.left,low,high)  // 寻找符合区间[low, high]的节点
        root.left = self.trimBST(root.left,low,high)  // root->left接入符合条件的左孩子
        root.right = self.trimBST(root.right,low,high)   // root->right接入符合条件的右孩子
        return root
```

### (37) 108、将有序数组转换为二叉搜索树
题目链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
#递归法
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def buildaTree(left,right):
            if left > right: return None  #左闭右闭的区间，当区间 left > right的时候，就是空节点,当left = right的时候，不为空
            mid = left + (right - left) // 2 #保证数据不会越界
            val = nums[mid]
            root = TreeNode(val)
            root.left = buildaTree(left,mid - 1)
            root.right = buildaTree(mid + 1,right)
            return root
        root = buildaTree(0,len(nums) - 1)  #左闭右闭区间
        return root
```

### (38) 538、把二叉搜索树转换为累加树
题目链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree/
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
#递归法
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        def buildalist(root): 
            if not root: return None
            buildalist(root.right)  #右中左遍历
            root.val += self.pre
            self.pre = root.val
            buildalist(root.left)
        self.pre = 0  #记录前一个节点的数值
        buildalist(root)
        return root
```

### 八、回溯算法 [↑](./README.md)

### 1、组合 [↑](./README.md)

### (1) 77、组合
题目链接：https://leetcode-cn.com/problems/combinations/
```python
#方法一：
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res=[]  #存放符合条件结果的集合
        path=[]  #用来存放符合条件结果
        def backtrack(n,k,startIndex):
            if len(path) == k:
                res.append(path[:])
                return 
            for i in range(startIndex,n+1):
                path.append(i)  #处理节点 
                backtrack(n,k,i+1)  #递归
                path.pop()  #回溯，撤销处理的节点
        backtrack(n,k,1)
        return res
	
#方法二：
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res=[]  #存放符合条件结果的集合
        path=[]  #用来存放符合条件结果
        def backtrack(n,k,startIndex):
            if len(path) == k:
                res.append(path[:])
            return 
            for i in range(startIndex,n-(k-len(path))+2):  #优化的地方
                path.append(i)  #处理节点 
                backtrack(n,k,i+1)  #递归
                path.pop()  #回溯，撤销处理的节点
    backtrack(n,k,1)
    return res
    
```

### (2) 216、组合总和III
题目链接：https://leetcode-cn.com/problems/combination-sum-iii/
```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        res = []  #存放结果集
        path = []  #符合条件的结果
        def findallPath(n,k,sum,startIndex):
            if sum > n: return  #剪枝操作
            if sum == n and len(path) == k:  #如果path.size() == k 但sum != n 直接返回
                return res.append(path[:])
            for i in range(startIndex,9-(k-len(path))+2):  #剪枝操作
                path.append(i)
                sum += i 
                findallPath(n,k,sum,i+1)  #注意i+1调整startIndex
                sum -= i  #回溯
                path.pop()  #回溯
        
        findallPath(n,k,0,1)
        return res
```

### (3) 17、电话号码的字母组合
题目链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/
```python
class Solution:
    ans = []
    s = ''
    letterMap = {
        '2': 'abc',
        '3': 'def',
        '4': 'ghi',
        '5': 'jkl',
        '6': 'mno',
        '7': 'pqrs',
        '8': 'tuv',
        '9': 'wxyz'
    }

    def letterCombinations(self, digits):
        self.ans.clear()
        if digits == '':
            return self.ans
        self.backtracking(digits, 0)
        return self.ans

    def backtracking(self, digits, index):
        if index == len(digits):
            self.ans.append(self.s)
            return
        else:
            letters = self.letterMap[digits[index]]  # 取出数字对应的字符集
            for letter in letters:
                self.s = self.s + letter  # 处理
                self.backtracking(digits, index + 1)
                self.s = self.s[:-1]      # 回溯
```

### (4) 39、组合总和
题目链接：https://leetcode-cn.com/problems/combination-sum/
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrack(candidates,target,sum,startIndex):
            if sum > target: return 
            if sum == target: return res.append(path[:])
            for i in range(startIndex,len(candidates)):
                if sum + candidates[i] >target: return  #如果 sum + candidates[i] > target 就终止遍历
                sum += candidates[i] 
                path.append(candidates[i])
                backtrack(candidates,target,sum,i)  #startIndex = i:表示可以重复读取当前的数
                sum -= candidates[i]  #回溯
                path.pop()  #回溯
        candidates = sorted(candidates)  #需要排序
        backtrack(candidates,target,0,0)
        return res
```

### (5) 40、组合总和II
题目链接：https://leetcode-cn.com/problems/combination-sum-ii/
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrack(candidates,target,sum,startIndex):
            if sum == target: res.append(path[:])
            for i in range(startIndex,len(candidates)):  #要对同一树层使用过的元素进行跳过
                if sum + candidates[i] > target: return 
                if i > startIndex and candidates[i] == candidates[i-1]: continue  #直接用startIndex来去重,要对同一树层使用过的元素进行跳过
                sum += candidates[i]
                path.append(candidates[i])
                backtrack(candidates,target,sum,i+1)  #i+1:每个数字在每个组合中只能使用一次
                sum -= candidates[i]  #回溯
                path.pop()  #回溯
        candidates = sorted(candidates)  #首先把给candidates排序，让其相同的元素都挨在一起。
        backtrack(candidates,target,0,0)
        return res
```


### 2、分割 [↑](./README.md)

### (6) 131、分割回文串
题目链接：https://leetcode-cn.com/problems/palindrome-partitioning/
```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []  
        path = []  #放已经回文的子串
        def backtrack(s,startIndex):
            if startIndex >= len(s):  #如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
                return res.append(path[:])
            for i in range(startIndex,len(s)):
                p = s[startIndex:i+1]  #获取[startIndex,i+1]在s中的子串
                if p == p[::-1]: path.append(p)  #是回文子串
                else: continue  #不是回文，跳过
                backtrack(s,i+1)  #寻找i+1为起始位置的子串
                path.pop()  #回溯过程，弹出本次已经填在path的子串
        backtrack(s,0)
        return res
```

### (7) 93、复原IP地址
题目链接：https://leetcode-cn.com/problems/restore-ip-addresses/
```python
class Solution(object):
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        ans = []
        path = []
        def backtrack(path, startIndex):
            if len(path) == 4:
                if startIndex == len(s):
                    ans.append(".".join(path[:]))
                    return
            for i in range(startIndex+1, min(startIndex+4, len(s)+1)):  # 剪枝
                string = s[startIndex:i]
                if not 0 <= int(string) <= 255:
                    continue
                if not string == "0" and not string.lstrip('0') == string:
                    continue
                path.append(string)
                backtrack(path, i)
                path.pop()

        backtrack([], 0)
        return ans```
```


### 3、子集 [↑](./README.md)

### (8) 78、子集
题目链接：https://leetcode-cn.com/problems/subsets/
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  
        path = []  
        def backtrack(nums,startIndex):
            res.append(path[:])  #收集子集，要放在终止添加的上面，否则会漏掉自己
            for i in range(startIndex,len(nums)):  #当startIndex已经大于数组的长度了，就终止了，for循环本来也结束了，所以不需要终止条件
                path.append(nums[i])
                backtrack(nums,i+1)  #递归
                path.pop()  #回溯
        backtrack(nums,0)
        return res
```

### (9) 90、子集II
题目链接：https://leetcode-cn.com/problems/subsets-ii/
```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []  #存放符合条件结果的集合
        path = []  #用来存放符合条件结果
        def backtrack(nums,startIndex):
            res.append(path[:])
            for i in range(startIndex,len(nums)):
                if i > startIndex and nums[i] == nums[i - 1]:  #我们要对同一树层使用过的元素进行跳过
                    continue
                path.append(nums[i])
                backtrack(nums,i+1)  #递归
                path.pop()  #回溯
        nums = sorted(nums)  #去重需要排序
        backtrack(nums,0)
        return res
```

### 4、排列 [↑](./README.md)

### (10) 491、递增子序列
题目链接：https://leetcode-cn.com/problems/increasing-subsequences/
```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def backtrack(nums,startIndex):
            repeat = []  #这里使用数组来进行去重操作
            if len(path) >=2:
                res.append(path[:])  #注意这里不要加return，要取树上的节点
            for i in range(startIndex,len(nums)):
                if nums[i] in repeat:
                    continue
                if len(path) >= 1:
                    if nums[i] < path[-1]:
                        continue
                repeat.append(nums[i])  #记录这个元素在本层用过了，本层后面不能再用了
                path.append(nums[i])
                backtrack(nums,i+1)
                path.pop()
        backtrack(nums,0)
        return res
```

### (11) 46、全排列
题目链接：https://leetcode-cn.com/problems/permutations/
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []  #存放符合条件结果的集合
        path = []  #用来存放符合条件的结果
        used = []  #用来存放已经用过的数字
        def backtrack(nums,used):
            if len(path) == len(nums):
                return res.append(path[:])  #此时说明找到了一组
            for i in range(0,len(nums)):
                if nums[i] in used:
                    continue  #used里已经收录的元素，直接跳过
                path.append(nums[i])
                used.append(nums[i])
                backtrack(nums,used)
                used.pop()
                path.pop()
        backtrack(nums,used)
        return res
```

### (12) 47、全排列II
题目链接：https://leetcode-cn.com/problems/permutations-ii/
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        # res用来存放结果
        if not nums: return []
        res = []
        used = [0] * len(nums)
        def backtracking(nums, used, path):
            # 终止条件
            if len(path) == len(nums):
                res.append(path.copy())
                return
            for i in range(len(nums)):
                if not used[i]:
                    if i>0 and nums[i] == nums[i-1] and not used[i-1]:
                        continue
                    used[i] = 1
                    path.append(nums[i])
                    backtracking(nums, used, path)
                    path.pop()
                    used[i] = 0
        # 记得给nums排序
        backtracking(sorted(nums),used,[])
        return res
```


### (13) 332、重新安排行程
题目链接：https://leetcode-cn.com/problems/reconstruct-itinerary/
```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        # defaultdic(list) 是为了方便直接append
        tickets_dict = defaultdict(list)
        for item in tickets:
            tickets_dict[item[0]].append(item[1])
        '''
        tickets_dict里面的内容是这样的
         {'JFK': ['SFO', 'ATL'], 'SFO': ['ATL'], 'ATL': ['JFK', 'SFO']})
        '''
        path = ["JFK"]
        def backtracking(start_point):
            # 终止条件
            if len(path) == len(tickets) + 1:
                return True
            tickets_dict[start_point].sort()
            for _ in tickets_dict[start_point]:
                #必须及时删除，避免出现死循环
                end_point = tickets_dict[start_point].pop(0)
                path.append(end_point)
                # 只要找到一个就可以返回了
                if backtracking(end_point):
                    return True
                path.pop()
                tickets_dict[start_point].append(end_point)

        backtracking("JFK")
        return path
```

### 5、棋盘问题 [↑](./README.md)

### (14) 51、N皇后问题
题目链接：https://leetcode-cn.com/problems/n-queens/
```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        if not n: return []
        board = [['.'] * n for _ in range(n)]
        res = []
        def isVaild(board,row, col):
            #判断同一列是否冲突
            for i in range(len(board)):
                if board[i][col] == 'Q':
                    return False
            # 判断左上角是否冲突
            i = row -1
            j = col -1
            while i>=0 and j>=0:
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j -= 1
            # 判断右上角是否冲突
            i = row - 1
            j = col + 1
            while i>=0 and j < len(board):
                if board[i][j] == 'Q':
                    return False
                i -= 1
                j += 1
            return True

        def backtracking(board, row, n):
            # 如果走到最后一行，说明已经找到一个解
            if row == n:
                temp_res = []
                for temp in board:
                    temp_str = "".join(temp)
                    temp_res.append(temp_str)
                res.append(temp_res)
            for col in range(n):
                if not isVaild(board, row, col):
                    continue
                board[row][col] = 'Q'
                backtracking(board, row+1, n)
                board[row][col] = '.'
        backtracking(board, 0, n)
        return res
```
### (15) 37、解数独
题目链接：https://leetcode-cn.com/problems/sudoku-solver/
```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        def backtrack(board):
            for i in range(len(board)):  #遍历行
                for j in range(len(board[0])):  #遍历列
                    if board[i][j] != ".": continue
                    for k in range(1,10):  #(i, j) 这个位置放k是否合适
                        if isValid(i,j,k,board):
                            board[i][j] = str(k)  #放置k
                            if backtrack(board): return True  #如果找到合适一组立刻返回
                            board[i][j] = "."  #回溯，撤销k
                    return False  #9个数都试完了，都不行，那么就返回false
            return True  #遍历完没有返回false，说明找到了合适棋盘位置了
        def isValid(row,col,val,board):
            for i in range(9):  #判断行里是否重复
                if board[row][i] == str(val):
                    return False
            for j in range(9):  #判断列里是否重复
                if board[j][col] == str(val):
                    return False
            startRow = (row // 3) * 3
            startcol = (col // 3) * 3
            for i in range(startRow,startRow + 3):  #判断9方格里是否重复
                for j in range(startcol,startcol + 3):
                    if board[i][j] == str(val):
                        return False
            return True
        backtrack(board)
```


### 九、贪心算法 [↑](./README.md)

### 1、简单题目 [↑](./README.md)

### (1) 455、分发饼干
题目链接：https://leetcode-cn.com/problems/assign-cookies/
```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        res = 0
        for i in range(len(s)):
            if res <len(g) and s[i] >= g[res]:  #小饼干先喂饱小胃口
                res += 1
        return res
```
### (2) 1005、K次取反后最大化的数组和
题目链接：https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/
```python
class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        A = sorted(A, key=abs, reverse=True) # 将A按绝对值从大到小排列
        for i in range(len(A)):
            if K > 0 and A[i] < 0:
                A[i] *= -1
                K -= 1
        if K > 0:
            A[len(A) - 1] *= ((-1)**K)
        return sum(A)
```
### (3) 860、柠檬水找零
题目链接：https://leetcode-cn.com/problems/lemonade-change/
```python
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        five, ten, twenty = 0, 0, 0
        for bill in bills:
            if bill == 5:
                five += 1
            elif bill == 10:
                if five < 1: return False
                five -= 1
                ten += 1
            else:
                if ten > 0 and five > 0:
                    ten -= 1
                    five -= 1
                    twenty += 1
                elif five > 2:
                    five -= 3
                    twenty += 1
                else:
                    return False
        return True
```
### 2、序列问题 [↑](./README.md)

### (4) 376、摆动序列
题目链接：https://leetcode-cn.com/problems/wiggle-subsequence/
```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        preC,curC,res = 0,0,1  #题目里nums长度大于等于1，当长度为1时，其实到不了for循环里去，所以不用考虑nums长度
        for i in range(len(nums) - 1):
            curC = nums[i + 1] - nums[i]
            if curC * preC <= 0 and curC !=0:  #差值为0时，不算摆动
                res += 1
                preC = curC  #如果当前差值和上一个差值为一正一负时，才需要用当前差值替代上一个差值
        return res
```
### (5) 738、单调递增的数字
题目链接：https://leetcode-cn.com/problems/monotone-increasing-digits/
```python
class Solution:
    def monotoneIncreasingDigits(self, n: int) -> int:
        strNum = list(str(n))
        flag = len(strNum)
        for i in range(len(strNum) - 1, 0, -1):
            if int(strNum[i]) < int(strNum[i - 1]):
                strNum[i - 1] = str(int(strNum[i - 1]) - 1)
                flag = i
        for i in range(flag, len(strNum)):
            strNum[i] = '9'
        return int("".join(strNum))
```
### 3、贪心算法解决股票问题 [↑](./README.md)

### (6) 122、买卖股票的最佳时机II
题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        result = 0
        for i in range(1, len(prices)):
            result += max(prices[i] - prices[i - 1], 0)
        return result
```

### (7) 714、买卖股票的最佳时机含手续费
题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/
```python
class Solution: # 贪心思路
    def maxProfit(self, prices: List[int], fee: int) -> int:
        result = 0
        minPrice = prices[0]
        for i in range(1, len(prices)):
            if prices[i] < minPrice:
                minPrice = prices[i]
            elif prices[i] >= minPrice and prices[i] <= minPrice + fee: 
                continue
            else: 
                result += prices[i] - minPrice - fee
                minPrice = prices[i] - fee
        return result
```

### 4、两个维度的权衡问题 [↑](./README.md)

### (8) 135、分发糖果
题目链接：https://leetcode-cn.com/problems/candy/
```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        candyVec = [1] * len(ratings)
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                candyVec[i] = candyVec[i - 1] + 1
        for j in range(len(ratings) - 2, -1, -1):
            if ratings[j] > ratings[j + 1]:
                candyVec[j] = max(candyVec[j], candyVec[j + 1] + 1)
        return sum(candyVec)
```
### (9) 406、根据身高重建序列
题目链接：https://leetcode-cn.com/problems/queue-reconstruction-by-height/
```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (x[0], -x[1]), reverse=True)
        que = []
        for p in people:
            if p[1] > len(que):
                que.append(p)
            else:
                que.insert(p[1], p)
        return que
```

### 5、区间问题 [↑](./README.md)
### (10) 55、跳跃游戏
题目链接：https://leetcode-cn.com/problems/jump-game/
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        cover = 0
        if len(nums) == 1: return True
        i = 0
        # python不支持动态修改for循环中变量,使用while循环代替
        while i <= cover:
            cover = max(i + nums[i], cover)
            if cover >= len(nums) - 1: return True
            i += 1
        return False
```
### (11) 45、跳跃游戏II
题目链接：https://leetcode-cn.com/problems/jump-game-ii/
```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) == 1: return 0
        ans = 0
        curDistance = 0
        nextDistance = 0
        for i in range(len(nums)):
            nextDistance = max(i + nums[i], nextDistance)
            if i == curDistance: 
                if curDistance != len(nums) - 1:
                    ans += 1
                    curDistance = nextDistance
                    if nextDistance >= len(nums) - 1: break
        return ans
```

### (12) 452、用最少数量的箭引爆气球
题目链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/
```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if len(points) == 0: return 0
        points.sort(key=lambda x: x[0])
        result = 1
        for i in range(1, len(points)):
            if points[i][0] > points[i - 1][1]: # 气球i和气球i-1不挨着，注意这里不是>=
                result += 1     
            else:
                points[i][1] = min(points[i - 1][1], points[i][1]) # 更新重叠气球最小右边界
        return result
```

### (13) 435、无重叠区间
题目链接：https://leetcode-cn.com/problems/non-overlapping-intervals/
```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if len(intervals) == 0: return 0
        intervals.sort(key=lambda x: x[1])
        count = 1 # 记录非交叉区间的个数
        end = intervals[0][1] # 记录区间分割点
        for i in range(1, len(intervals)):
            if end <= intervals[i][0]:
                count += 1
                end = intervals[i][1]
        return len(intervals) - count
```

### (14) 763、划分字母区间
题目链接： https://leetcode-cn.com/problems/partition-labels/
```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        hash = [0] * 26
        for i in range(len(s)):
            hash[ord(s[i]) - ord('a')] = i
        result = []
        left = 0
        right = 0
        for i in range(len(s)):
            right = max(right, hash[ord(s[i]) - ord('a')])
            if i == right:
                result.append(right - left + 1)
                left = i + 1
        return result
	
```

### (15) 56、合并区间
题目链接：https://leetcode-cn.com/problems/merge-intervals/
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if len(intervals) == 0: return intervals
        intervals.sort(key=lambda x: x[0])
        result = []
        result.append(intervals[0])
        for i in range(1, len(intervals)):
            last = result[-1]
            if last[1] >= intervals[i][0]:
                result[-1] = [last[0], max(last[1], intervals[i][1])]
            else:
                result.append(intervals[i])
        return result
```
### 6、其他 [↑](./README.md)

### (16) 134、加油站
题目链接：https://leetcode-cn.com/problems/gas-station/
```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        start = 0
        curSum = 0
        totalSum = 0
        for i in range(len(gas)):
            curSum += gas[i] - cost[i]
            totalSum += gas[i] - cost[i]
            if curSum < 0:
                curSum = 0
                start = i + 1
        if totalSum < 0: return -1
        return start
```
### (17) 53、最大子序和
题目链接：https://leetcode-cn.com/problems/maximum-subarray/
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        result = -float('inf')
        count = 0
        for i in range(len(nums)):
            count += nums[i]
            if count > result:
                result = count
            if count <= 0:
                count = 0
        return result
```
### (18) 968、监控二叉树
题目链接：https://leetcode-cn.com/problems/binary-tree-cameras/
```python
class Solution:
    def minCameraCover(self, root: TreeNode) -> int:
        result = 0
        def traversal(cur):
            nonlocal result
            if not cur:
                return 2
            left = traversal(cur.left)
            right = traversal(cur.right)
            if left == 2 and right == 2:
                return 0
            elif left == 0 or right == 0:
                result += 1
                return 1
            elif left == 1 or right == 1:
                return 2
            else: return -1
        if traversal(root) == 0: result += 1
        return result
```
### 十、动态规划问题 [↑](./README.md)


### 1、基础题目 [↑](./README.md)

### (1) 509、斐波那契数
题目链接：https://leetcode-cn.com/problems/fibonacci-number/
```c++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        a, b, c = 0, 1, 0
        for i in range(1, n):
            c = a + b
            a, b = b, c
        return c

# 递归实现
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        return self.fib(n - 1) + self.fib(n - 2)
```

### (2) 70、爬楼梯
题目链接：https://leetcode-cn.com/problems/climbing-stairs/
```c++
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        # dp[i]表示爬到第i级楼梯的种数， (1, 2) (2, 1)是两种不同的类型
        dp = [0] * (n + 1)
        dp[0] = 1
        for i in range(n+1):
            for j in range(1, 3):
                if i>=j:
                    dp[i] += dp[i-j]
        return dp[-1]
```

```python
#法二：
class Solution:
    def climbStairs(self, n: int) -> int:
        if n<=2:
            return n
        a,b,c=1,2,0
        for i in range(2,n):
            c=a+b
            a,b=b,c
        return c      
```
### (3) 746、使用最小花费爬楼梯
题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/
```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值
        return min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
```

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        dp = [0] * (len(cost))
        dp[0] = cost[0]
        dp[1] = cost[1]
        for i in range(2, len(cost)):
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
        return min(dp[len(cost) - 1], dp[len(cost) - 2])
```

### (4) 62、不同路径
题目链接：https://leetcode-cn.com/problems/unique-paths/
```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

```python
class Solution: # 动态规划
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0 for i in range(n)] for j in range(m)]
        for i in range(m): dp[i][0] = 1
        for j in range(n): dp[0][j] = 1
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
        return dp[m - 1][n - 1]
```

### (5) 63、不同路径II
题目链接：https://leetcode-cn.com/problems/unique-paths-ii/
```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        # 构造一个DP table
        row = len(obstacleGrid)
        col = len(obstacleGrid[0])
        dp = [[0 for _ in range(col)] for _ in range(row)]

        dp[0][0] = 1 if obstacleGrid[0][0] != 1 else 0
        if dp[0][0] == 0: return 0  # 如果第一个格子就是障碍，return 0
        # 第一行
        for i in range(1, col):
            if obstacleGrid[0][i] != 1:
                dp[0][i] = dp[0][i-1]

        # 第一列
        for i in range(1, row):
            if obstacleGrid[i][0] != 1:
                dp[i][0] = dp[i-1][0]
        print(dp)

        for i in range(1, row):
            for j in range(1, col):
                if obstacleGrid[i][j] != 1:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

### (6) 343、整数拆分
题目链接：https://leetcode-cn.com/problems/integer-break/
```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[2] = 1
        for i in range(3, n + 1):
            # 假设对正整数 i 拆分出的第一个正整数是 j（1 <= j < i），则有以下两种方案：
            # 1) 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j * (i-j)
            # 2) 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i-j]
            for j in range(1, i):
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
        return dp[n]
```

### (7) 96、不同的二叉搜索树
题目链接：https://leetcode-cn.com/problems/unique-binary-search-trees/
```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1
        for i in range(2, n + 1):
            for j in range(1, i + 1):
                dp[i] += dp[j - 1] * dp[i - j]
        return dp[-1]
```

### 2、背包问题 [↑](./README.md)

### 2.1 01背包 [↑](./README.md)

### (8) 01背包问题
#### 问题描述:
```
有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
```
#### C++实现
```C++
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagWeight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagWeight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}
```

### (9) 416、分割等和子集
题目链接：https://leetcode-cn.com/problems/partition-equal-subset-sum/
```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;

        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int> dp(10001, 0);
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        if (sum % 2 == 1) return false;
        int target = sum / 2;

        // 开始 01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        // 集合中的元素正好可以凑成总和target
        if (dp[target] == target) return true;
        return false;
    }
};
```

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        taraget = sum(nums)
        if taraget % 2 == 1: return False
        taraget //= 2
        dp = [0] * 10001
        for i in range(len(nums)):
            for j in range(taraget, nums[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
        return taraget == dp[taraget]
```
### (10) 1049、最后一块石头的重量II
题目链接：https://leetcode-cn.com/problems/last-stone-weight-ii/
```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001, 0);
        int sum = 0;
        for (int i = 0; i < stones.size(); i++) sum += stones[i];
        int target = sum / 2;
        for (int i = 0; i < stones.size(); i++) { // 遍历物品
            for (int j = target; j >= stones[i]; j--) { // 遍历背包
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};
```

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        sumweight = sum(stones)
        target = sumweight // 2
        dp = [0] * 15001
        for i in range(len(stones)):
            for j in range(target, stones[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])
        return sumweight -  2 * dp[target]
```

### (11) 494、目标和
题目链接：https://leetcode-cn.com/problems/target-sum/
```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
       int sum = 0;
       int n = nums.size();
       for(int i=0;i<n;i++) sum+=nums[i];
       
       if(sum<target) return 0;
       if((sum+target)%2==1) return 0;
       if(n==1){
           if(sum==target || -sum==target) return 1;
           else return 0;
       } 
       int left = (target+sum)/2;

       vector<int> dp(left+1,0);
       dp[0] = 1;

       for(int i=0;i<n;i++){
           for(int j=left;j>=nums[i];j--){
               dp[j]+=dp[j-nums[i]];
           }
       }

       return dp[left];
    }
};
```

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        sumValue = sum(nums)
        if target > sumValue or (sumValue + target) % 2 == 1: return 0
        bagSize = (sumValue + target) // 2
        dp = [0] * (bagSize + 1)
        dp[0] = 1
        for i in range(len(nums)):
            for j in range(bagSize, nums[i] - 1, -1):
                dp[j] += dp[j - nums[i]]
        return dp[bagSize]
```

### (12) 474、一和零
题目链接：https://leetcode-cn.com/problems/ones-and-zeroes/
```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0] * (n + 1) for _ in range(m + 1)]	# 默认初始化0
        # 遍历物品
        for str in strs:
            ones = str.count('1')
            zeros = str.count('0')
            # 遍历背包容量且从后向前遍历！
            for i in range(m, zeros - 1, -1):
                for j in range(n, ones - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)
        return dp[m][n]
```
### 2.2 完全背包 [↑](./README.md)

### (13) 完全背包问题
#### 问题描述:
```
有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。
```
#### C++代码实现
```C++
// 先遍历物品，在遍历背包
void test_CompletePack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
int main() {
    test_CompletePack();
}
```

### (14) 518、零钱兑换II
题目链接：https://leetcode-cn.com/problems/coin-change-2/
```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0]*(amount + 1)
        dp[0] = 1
        # 遍历物品
        for i in range(len(coins)):
            # 遍历背包
            for j in range(coins[i], amount + 1):
                dp[j] += dp[j - coins[i]]
        return dp[amount]
```

### (15) 377、组合总和IV
题目链接：https://leetcode-cn.com/problems/combination-sum-iv/
```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; i++) { // 遍历背包
            for (int j = 0; j < nums.size(); j++) { // 遍历物品
                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
```

```python
class Solution:
    def combinationSum4(self, nums, target):
        dp = [0] * (target + 1)
        dp[0] = 1

        for i in range(1, target+1):
            for j in nums:
                if i >= j:
                    dp[i] += dp[i - j]

        return dp[-1]
```

### (16) 70、爬楼梯
题目链接：https://leetcode-cn.com/problems/climbing-stairs/
```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历背包
            for (int j = 1; j <= m; j++) { // 遍历物品
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```

### (17) 322、零钱兑换
题目链接：https://leetcode-cn.com/problems/coin-change/
```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```

### (18) 276、完全平方数
题目链接：https://leetcode-cn.com/problems/perfect-squares/
```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i <= n; i++) { // 遍历背包
            for (int j = 1; j * j <= i; j++) { // 遍历物品
                dp[i] = min(dp[i - j * j] + 1, dp[i]);
            }
        }
        return dp[n];
    }
};
```

### (19) 139、单词拆分
题目链接：https://leetcode-cn.com/problems/word-break/
```C++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```

### 2.3 多重背包 [↑](./README.md)

### (20) 多重背包问题:
#### 问题描述： 
```
有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大
```
#### C++实现
```C++
void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    for (int i = 0; i < nums.size(); i++) {
        while (nums[i] > 1) { // nums[i]保留到1，把其他物品都展开
            weight.push_back(weight[i]);
            value.push_back(value[i]);
            nums[i]--;
        }
    }

    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;

}
int main() {
    test_multi_pack();
}
```

### 3、打家劫舍 [↑](./README.md)

### (21) 198、打家劫舍
题目链接：https://leetcode-cn.com/problems/house-robber/
```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        return dp[-1]
```

### (22) 213、打家劫舍II
题目链接：https://leetcode-cn.com/problems/house-robber-ii/
```c++
// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
```

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
      if (n := len(nums)) == 0:
        return 0
      if n == 1:
        return nums[0]
      result1 = self.robRange(nums, 0, n - 2)
      result2 = self.robRange(nums, 1, n - 1)
      return max(result1 , result2)

    def robRange(self, nums: List[int], start: int, end: int) -> int:
      if end == start: return nums[start]
      dp = [0] * len(nums)
      dp[start] = nums[start]
      dp[start + 1] = max(nums[start], nums[start + 1])
      for i in range(start + 2, end + 1):
        dp[i] = max(dp[i -2] + nums[i], dp[i - 1])
      return dp[end]
```

### (23) 337、打家劫舍III
题目链接：https://leetcode-cn.com/problems/house-robber-iii/
```c++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```

```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        result = self.robTree(root)
        return max(result[0], result[1])
    
    #长度为2的数组，0：不偷，1：偷
    def robTree(self, cur):
        if not cur:
            return (0, 0) #这里返回tuple, 也可以返回list
        left = self.robTree(cur.left)
        right = self.robTree(cur.right)
        #偷cur
        val1 = cur.val + left[0] + right[0]
        #不偷cur
        val2 = max(left[0], left[1]) + max(right[0], right[1])
        return (val2, val1)
```


### 4、股票问题 [↑](./README.md)

### (24) 121、买卖股票的最佳时机
题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```

### (25) 122、买卖股票的最佳时机II
题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

### (26) 123、买卖股票的最佳时机III
题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```

### (27) 188、买卖股票的最佳时机IV
题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/
```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

### (28) 309、最佳买卖股票时机含冷冻期
题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3],max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```

### (29) 714、买卖股票的最佳时机含手续费
题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```
### 5、子序列问题 [↑](./README.md)

### 5.1 子序列不连续 [↑](./README.md)

### (30) 300、最长递增子序列
题目链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/
```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }
        return result;
    }
};
```

### (31) 1143、最长公共子序列
题目链接：https://leetcode-cn.com/problems/longest-common-subsequence/
```C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len1, len2 = len(text1)+1, len(text2)+1
        dp = [[0 for _ in range(len1)] for _ in range(len2)] # 先对dp数组做初始化操作
        for i in range(1, len2):
            for j in range(1, len1): # 开始列出状态转移方程
                if text1[j-1] == text2[i-1]:
                    dp[i][j] = dp[i-1][j-1]+1 
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[-1][-1]
```

### (32) 1035、不相交的线
题目链接：https://leetcode-cn.com/problems/uncrossed-lines/
```c++
class Solution {
public:
    int maxUncrossedLines(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp(A.size() + 1, vector<int>(B.size() + 1, 0));
        for (int i = 1; i <= A.size(); i++) {
            for (int j = 1; j <= B.size(); j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[A.size()][B.size()];
    }
};
```

### 5.2 子序列连续 [↑](./README.md)


### (33) 674、最长连读递增序列
题目链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/
```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int result = 1;
        vector<int> dp(nums.size() ,1);
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) { // 连续记录
                dp[i + 1] = dp[i] + 1;
            }
            if (dp[i + 1] > result) result = dp[i + 1];
        }
        return result;
    }
};
```

### (34) 718、最长重复子数组
题目链接：https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/
```C++
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp (A.size() + 1, vector<int>(B.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= A.size(); i++) {
            for (int j = 1; j <= B.size(); j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
};
```


### (35) 53、最大子序和
题目链接：https://leetcode-cn.com/problems/maximum-subarray/
```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式
            if (dp[i] > result) result = dp[i]; // result 保存dp[i]的最大值
        }
        return result;
    }
};
```

### 5.3 编辑距离 [↑](./README.md)
### (36) 392、判断子序列
题目链接：https://leetcode-cn.com/problems/is-subsequence/
```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = dp[i][j - 1];
            }
        }
        if (dp[s.size()][t.size()] == s.size()) return true;
        return false;
    }
};
```

### (37) 115、不同的子序列
题目链接：https://leetcode-cn.com/problems/distinct-subsequences/
```C++
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));
        for (int i = 0; i < s.size(); i++) dp[i][0] = 1;
        for (int j = 1; j < t.size(); j++) dp[0][j] = 0;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

### (38) 583、两个字符串的删除操作
题目链接：https://leetcode-cn.com/problems/delete-operation-for-two-strings/
```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### (39) 72、编辑距离
题目链接：https://leetcode-cn.com/problems/edit-distance/
```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else {
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```
### 5.4 回文 [↑](./README.md)

### (40) 647、回文子串
题目链接：https://leetcode-cn.com/problems/palindromic-substrings/
```C++
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        for (int i = s.size() - 1; i >= 0; i--) {  // 注意遍历顺序
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) { // 情况一 和 情况二
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { // 情况三
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }
};
```

### (41) 516、最长回文子序列
题目链接：https://leetcode-cn.com/problems/longest-palindromic-subsequence/
```C++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][s.size() - 1];
    }
};
```

